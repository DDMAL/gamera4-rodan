<?xml version="1.0" encoding="utf-8" ?>
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml" xml:lang="en" lang="en">
<head>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
<meta name="generator" content="Docutils 0.15.2: http://docutils.sourceforge.net/" />
<title>overriding_knn_features.txt</title>
<link rel="stylesheet" href="default.css" type="text/css" />
</head>
<body>
<div class="document">


<p>b'===================================nOverriding kNN's feature generationn===================================nn**Last modified**: June 03, 2019nn.. contents::nn.. role:: raw-html(raw)n   :format: htmln.. footer:: <a href="#id1"><span class="problematic" id="id2">:raw-html:`&lt;div style=&quot;text-align:right;&quot;&gt;For contact information, see &lt;a href=&quot;http://gamera.informatik.hsnr.de/contact.html&quot;&gt;http://gamera.informatik.hsnr.de/contact.html&lt;/a&gt;&lt;/div&gt;`</span></a>nnnIntroductionn------------nnThe classifier automatically manages the generation of feature vectorsnfrom glyphs.  When a feature vector is needed because it is beingnclassified or added to the training set, it is automatically generatednon-the-fly.nnBy default, the feature generation method in kNN is quite simple.  Thenuser of the classifier provides a list of feature function namesn(either in the constructor or through the <tt class="docutils literal">change_feature_set</tt>nmethod), and for each glyph, the results of each feature function innthe set are appended together to produce a feature vector.nnThis simple feature generation method can be overridden and replacednwith something more appropriate to specific problem domains.  The onlynrestriction (which is an inherent limitation of the <em>k</em>-nearestnneighbor algorithm) is that the length of the feature vectors must benthe same for all glyphs within a single classifier.  If your problemnrequires variable-length feature vectors, you will need to use anothernkind of classifier or use multiple kNN classifiers.nnCreating a subclass of <tt class="docutils literal">kNN</tt>n------------------------------nnChanging how feature generation works is as simple as creating a newnclass that inherits from either <tt class="docutils literal">kNNInteractive</tt> orn``kNNNonInteractive`` and overriding the <tt class="docutils literal">generate_features</tt> method.n``__init__`` may also be overridden in order to accept parametersnspecific to the class.nn.. code:: Pythonnn   from gamera import knn, classifyn   import arraynn   class MykNN(knn.kNNInteractive):n      def __init__(self, database, num_features, perform_splits=True):n         ... described below ...nn      def generate_features(self, glyph):n         ... described below ...t n    nn``__init__``n''''''''''''nnThe __init__ function must do two things:nn    - initialize the low-level kNN classifier and set the length of then      feature vectors.nn    - initialize the high-level classifier interface with the initialn      database of glyphs (or filename).nnIn the example below, the length of the feature vector is set using annargument to the constructor.  Note that this is in contrast to thendefault behavior, where a list of feature functions is passed in andnthe length of the feature vectors is calculated from that.nn.. code:: Pythonnn  def __init__(self, database, num_features, perform_splits=True):n     knn._kNNBase.__init__(self, num_features)n     classify.InteractiveClassifier.__init__(self, database, perform_splits=perform_splits)     nn``generate_features``n'''''''''''''''''''''nnThe <tt class="docutils literal">generate_features</tt> function is where the feature generationnactually happens and is called every time the classifier needs anfeature vector for a particular glyph.nnThe feature vector itself must be stored in the member <tt class="docutils literal">features</tt> ofnthe glyph itself.  This <em>must</em> be a Python <tt class="docutils literal">array</tt> of <tt class="docutils literal">double</tt>,nand its length must be equal to the feature vector length for thenwhole classifier.  For efficiency reasons, the type-checking withinnkNN is very weak, so this point is very important.nnOf course, the actual content of the feature vector will be computednthrough some process (which is the whole point of this document).nnAs a trivial example, the following simply generates a feature vectornfull of zeros:nn.. code:: Pythonnn  def generate_features(self, glyph):n    glyph.features = array.array('d', [0] * self.num_features)nnPitfalls and performance issuesn'''''''''''''''''''''''''''''''nnWhen you start to put this into a real system, things get morencomplex. <tt class="docutils literal">generate_features</tt> may be called multiple times on thensame glyph.  For instance, this can happen when the same glyph isnclassified more than once.  More dangerously, it can happen whennglyphs are moved around between different classifiers.  If thosenclassifiers have different length feature vectors (or even differentnsets and ordering of features) things won't work as expected, becausenthe classifiers will be sharing incompatible feature vectors.  It isntherefore a good idea to always either keep the sets of glyphsnorthogonal between all active classifiers, or copy the glyph instancesnwhen moving from one classifier to another.nnCalling <tt class="docutils literal">generate_features</tt> multiple times on the same glyph maynalso have performance implications.  In the default implementation,nwhen a feature vector is generated, the feature functions that werenused to generate it are also stored in a member of the glyph.  Thennext time <tt class="docutils literal">generate_features</tt> is called for the glyph, the featurenvector is re-generated <em>only</em> if the set of feature functions beingnused is different from the last time they were generated.  This savesna redundant time-consuming feature generation operation.nnIt is impossible for the classifier system to know what externalnforces will require feature regeneration, so it is the resposibilitynof the custom <tt class="docutils literal">generate_features</tt> method to determine the need tonregenerate.nnIn the following example, the feature vector is regenerated if thenfeature vector length has changed since the last time it was generated.nn.. code:: Pythonnn  def generate_features(self, glyph):n    if len(glyph.features) != self.num_features:n        glyph.features = array.array('d', [0] * self.num_features)nn'</p>
<div class="system-message" id="id1">
<p class="system-message-title">System Message: ERROR/3 (<tt class="docutils">./src/overriding_knn_features.txt</tt>, line 1); <em><a href="#id2">backlink</a></em></p>
Unknown interpreted text role &quot;raw-html&quot;.</div>
</div>
</body>
</html>
