<?xml version="1.0" encoding="utf-8" ?>
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml" xml:lang="en" lang="en">
<head>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
<meta name="generator" content="Docutils 0.15.2: http://docutils.sourceforge.net/" />
<title>writing_plugins.txt</title>
<link rel="stylesheet" href="default.css" type="text/css" />
</head>
<body>
<div class="document">


<p>b'======================nWriting Gamera Pluginsn======================nn**Last modified**: June 03, 2019nn.. contents::nn.. role:: raw-html(raw)n   :format: htmln.. footer:: <a href="#id1"><span class="problematic" id="id2">:raw-html:`&lt;div style=&quot;text-align:right;&quot;&gt;For contact information, see &lt;a href=&quot;http://gamera.informatik.hsnr.de/contact.html&quot;&gt;http://gamera.informatik.hsnr.de/contact.html&lt;/a&gt;&lt;/div&gt;`</span></a>nnnIntroductionn============nnThe functionality of Gamera can be extended by writing plugins inneither C++ or Python.  A plugin is simply a set of methods (which arenautomagically added to the <tt class="docutils literal">Image</tt> class) or free-standingnfunctions.  Plugins are technically just Python modules, but with moreninformation that allows for easier wrapping and compilation of C++nmethods and to support all kinds of automatic things in the graphicalnuser interface.nnPlugins can also be grouped together, with other tools, into toolkits.nToolkits provide higher-level workflow framework for end-to-endndocument recognition by joining together a number of steps fromnvarious plugins.  Toolkits are a whole other discussion, so see then`writing Gamera toolkits`__ for more information.nn.. __: writing_toolkits.htmlnnBefore writing any plugin, you should make sure there isn't already anplugin included that does what you want.  Look at the <a href="#id4"><span class="problematic" id="id5">`list of plugins\nincluded with Gamera`__</span></a>.nn.. __: plugins.htmlnnThe files involvedn------------------nnEach plugin is made up of two files: nn1. A Python file that describes each method in the plugin and then   plugin itself.  If any methods are &quot;pure Python&quot;, they can also ben   defined here, or they can just delegate to functions in othern   Python modules.nn2. Optionally, a C++ header file containing implementations of any C++n   methods of the plugin.  This is a header file (<tt class="docutils literal">.hpp</tt>) and not ann   implementation file (<tt class="docutils literal">.cpp</tt>) because the code you write will be templatizedn   and the concrete methods and the glue code connecting to Python ton   C++ will be generated automatically at compile time by the Gameran   build system.  (What templates are is beyond the scope of thisn   document, but it's covered very well in <a href="#id10"><span class="problematic" id="id3">[Stroustrup1997]_</span></a>.)nnPlugins in the Gamera source treen`````````````````````````````````nThe Python metadata files are stored in <tt class="docutils literal">./gamera/plugins/</tt> and thenC++ source files are stored in <tt class="docutils literal">./include/plugins</tt>.nnIf you keep these files in the proper directories, they will benautomatically picked up by the build system and compiled.  When Gameranis started up, it will search the <tt class="docutils literal">./gamera/plugins</tt> directory and loadnall plugins.nnPlugins in a toolkitn````````````````````nnIn a toolkit, the Python metadata files are stored inn``./gamera/toolkits/my_toolkit/plugins/`` and the C++ source files arenstored in <tt class="docutils literal">./include/plugins</tt>, both rooted at the top of yourntoolkit directory.nnPlugin modules included in toolkits will have to be explicitlynimported before they are available.nnA simple examplen================nnPlugin metadatan---------------nnLet's look at a simple metadata file, <tt class="docutils literal">example.py</tt>.  Each method isndescribed by creating a class that inherits fromn``gamera.plugin.PluginFunction`` and defining a number of specialnmembers.  The whole plugin is described by a class that inherits fromn``gamera.plugin.PluginModule``:nn.. code:: Pythonnn  from gamera.plugin import <em>n  import _examplenn  # C++ methodn  class volume(PluginFunction):n      &quot;&quot;&quot;n      Returns the ratio of black pixels to white pixels within then      bounding box of the image.n      &quot;&quot;&quot;n      self_type = ImageType([ONEBIT])n      return_type = Float(&quot;volume&quot;)n      doc_examples = [(ONEBIT,)]nn  class ExampleModule(PluginModule):n      category = &quot;Example&quot;n      cpp_headers=[&quot;example.hpp&quot;]n      functions = [volume]n      author = &quot;Michael Droettboom and Karl MacMillan&quot;n      url = &quot;http://gamera.informatik.hsnr.de/&quot;n  module = ExampleModule()nnOkay, now let's break it down.nnThe ``gamera.plugin`` module contains all of the utilities necessary toncreate Gamera plugins, so the first thing we do is import it:nn.. code:: Pythonnn  from gamera.plugin import *nnNext, we import the C++ (compiled object file) side of the plugin,n(described in the next section) which *always</em> has the same name asnthe Python metadata module, except with a leading underscore:nn.. code:: Pythonnn  import _examplennLet's start by describing a minimal C++ method.  All methods andnfunctions in a plugin are described using a class that inherits fromn``gamera.plugin.PluginFunction``:nn.. code:: Pythonnn  # C++ methodn  class volume(PluginFunction):nnEach plugin can (and should) be documented in the usual <a href="#id4"><span class="problematic" id="id6">`Python\ndocstring`__</span></a> way:nn.. code:: Pythonnn      &quot;&quot;&quot;n      Returns the ratio of black pixels to white pixels within then      bounding box of the image.n      &quot;&quot;&quot;nn.. __: http://www.python.org/doc/current/tut/node6.htmlnnOn a related note, you can also have the documentation systemn(<tt class="docutils literal">doc/gendoc.py</tt>) generate an example automatically.  Seen`documenting and unit-testing Plugin functions`_. nnNext, we define <tt class="docutils literal">self_type</tt>, which is the type of object this methodncan be called on.  If <tt class="docutils literal">self_type</tt> is an <tt class="docutils literal">ImageType</tt>, the methodnwill automatically be added to all <tt class="docutils literal">Image</tt> objects in Gameranwhenever the plugin is imported.  Within the <tt class="docutils literal">ImageType</tt> specifier,nyou can choose which types of pixels are supported using a list ofnpixel type names. Valid options are <tt class="docutils literal">ONEBIT</tt>, <tt class="docutils literal">GREYSCALE</tt>,n``GREY16``, <tt class="docutils literal">FLOAT</tt> and <tt class="docutils literal">RGB</tt> (these are all constants importednfrom the <tt class="docutils literal">gamera.plugin module</tt>):nn.. code:: Pythonnn      self_type = ImageType([ONEBIT])nnYou can also optionally define <tt class="docutils literal">return_type</tt>.  This specifier isnused to generate a variable name for the result in the GUI, and so thenC++ wrapping mechanism knows how to return the result to Python.  Ifnyou don't specify a return type, Gamera assumes there is no returnnresult:nn.. code:: Pythonnn      return_type = Float(&quot;volume&quot;)nnObviously, this is a very simple plugin method with no arguments.nSome more involved examples are given below.  In the meantime, let'snlook at how this method is contained in a plugin module.nnFor each plugin module, you also need a class to describe the entirenplugin.  There may be <em>only one</em> of these classes per plugin.  This isndone in a similar manner to how the methods are described.nnThere is a class that inherits from <tt class="docutils literal">gamera.plugin.PluginModule</tt>:nn.. code:: Pythonnn  class ExampleModule(PluginModule):nnYou can specify a category for the plugin's methods onnthe context (right-click) menu in the GUI:nn.. code:: Pythonnn    category = &quot;Example&quot;nnIf you have any C++ methods (which we do in this case), you mustnspecify the C++ header files to include which contain thencorresponding method's source code:nn.. code:: Pythonnn    cpp_headers=[&quot;example.hpp&quot;]nnYou must also list all of the plugins and methods in the file so theyncan be generated and loaded:nn.. code:: Pythonnn    functions = [volume]nnOptionally, the author names and a URL for more information can benspecified:nn.. code:: Pythonnn    author = &quot;Michael Droettboom and Karl MacMillan&quot;n    url = &quot;http://gamera.informatik.hsnr.de/&quot;nnLastly, we create an instance of this class so the module loader canndo its work:nn.. code:: Pythonnn  module = ExampleModule()nnC++ coden--------nnSince the <tt class="docutils literal">volume</tt> method needs to look at individual pixels, it isnlikely going to be much faster written in C++ than in Python.  Belownis the corresponding <tt class="docutils literal">example.hpp</tt> that contains the C++nimplementation:nn.. code:: CPPnn  #include &quot;gamera.hpp&quot;nn  using namespace Gamera;nn  template&lt;class T&gt;n  float volume(const T &amp;m) {n    unsigned int count = 0;n    typename T::const_vec_iterator i = m.vec_begin();n    for (; i != m.vec_end(); i++)n      if (is_black(<em>i))n        count++;n    return (feature_t(count) / (m.nrows() * m.ncols()));n  }nnMost of the declarations needed for Gamera are in ``gamera.hpp``, andnall of that stuff is in the ``Gamera`` namespace, to prevent namencollisions.  You may find it most convenient to just put ``usingnnamespace Gamera`` at the top of your plugin file, rather thannspecifying ``Gamera::...`` everywhere:nn.. code:: CPPnn  #include &quot;gamera.hpp&quot;n n  using namespace Gamera;nnNext we get to the function itself.  Note that it is templatized.nSince it is our goal to write a single algorithm that may work onnmultiple image types, *all</em> plugin methods are templatized, and theninstantiations of these templates are generated by the Gamera buildnsystem at compile-time based on the <tt class="docutils literal">self_type</tt> specifier in thenmethod metadata class (that we specified in <tt class="docutils literal">example.py</tt>).  See hownthe first argument <tt class="docutils literal">self</tt> is templatized as <tt class="docutils literal">T</tt> so that anyn(image) type can be passed in.  The body of the function used then`Gamera C++ Image API`__ to access and examine the individual pixels:nn.. code:: CPPnn    template&lt;class T&gt;n    float volume(const T &amp;m) {n      unsigned int count = 0;n      typename T::const_vec_iterator i = m.vec_begin();n      for (; i != m.vec_end(); i++)n        if (is_black(<em>i))n          count++;n      return (feature_t(count) / (m.nrows() * m.ncols()));n    }nn.. __: image_api.htmlnnBuilding the pluginn-------------------nnOkay, so now we're done with the minimal plugin, but obviouslynsomething more has to happen in order to access the C++ code from Python.nFortunately, that is all done automatically by the Gamera buildnsystem.  If the ``example.py`` is placed in the ``./gamera/plugins``ndirectory, the build system will automatically find it, use thenmetadata to generate a *wrapper</em> to access <tt class="docutils literal">example.hpp</tt>, and compileneverything.  The next time Gamera is run, the plugin willnautomatically be loaded.  The plugin author does not have to learnnabout the intricacies of the <a href="#id4"><span class="problematic" id="id7">`Python/C API`__</span></a>.nn.. __: <a class="reference external" href="http://www.python.org/doc/current/api/api.htmlnnBut">http://www.python.org/doc/current/api/api.htmlnnBut</a>, for the sake of some sick curiosity, the generated code looksnsomething like:nn.. code:: CPPnn  #include &lt;string&gt;n  #include &lt;stdexcept&gt;n  #include &quot;Python.h&quot;n  #include &lt;list&gt;n  #include &quot;gameramodule.hpp&quot;nn  init_features (void)n  {n    Py_InitModule (&quot;_features&quot;, _features_methods);n  }nn  #include &quot;features.hpp&quot;n n  using namespace Gamera;nn  extern &quot;C&quot;n  {n    void init_example (void);n    static PyObject <em>call_volume (PyObject * self, PyObject * args);n    static PyMethodDef _features_methods[] =n      { {&quot;volume&quot;, call_volume, METH_VARARGS} };nn    static PyObject *call_volume(PyObject * self, PyObject * args)n    {n      PyObject *real_self;n      Image *real_self_image;nn      FloatVector *return_value = 0;nn      if (PyArg_ParseTuple(args, &quot;O&quot;, &amp;real_self) &lt;= 0)n        return 0;n      if (!is_ImageObject(real_self)) {ntPyErr_SetString(PyExc_TypeError, &quot;Object is not an image as expected!&quot;);ntreturn 0;n      }n      real_self_image = ((Image *) ((RectObject *) real_self)-&gt;m_x);n      image_get_fv(real_self, &amp;real_self_image-&gt;features, &amp;real_self_image-&gt;features_len);n      try {n      switch (get_image_combination (real_self)) {ntcase ONEBITRLEIMAGEVIEW:nt  return_value = volume(*((OneBitRleImageView *) real_self_image));nt  break;ntcase RLECC:nt  return_value = volume(*((RleCc *) real_self_image));nt  break;ntcase CC:nt  return_value = volume(*((Cc *) real_self_image));nt  break;ntcase ONEBITIMAGEVIEW:nt  return_value = volume (*((OneBitImageView *) real_self_image));nt  break;ntdefault:nt  PyErr_SetString (PyExc_TypeError,nttt   &quot;Image types do not match function signature.&quot;);nt  return 0;nt}n      }n      catch (std::exception &amp; e)n      {n        PyErr_SetString (PyExc_RuntimeError, e.what());n        return 0;n      }n      PyObject *array_init = get_ArrayInit();n      if (array_init == 0)n        return 0;n      PyObject *str = PyString_FromStringAndSize((char *) (&amp;((*return_value)[0])),nttt     t  return_value-&gt;size () * sizeof (double));n      PyObject *array = PyObject_CallFunction(array_init, &quot;sO&quot;, &quot;d&quot;, str);n      delete return_value;n      return array;n    }n    DL_EXPORT (void) init_example (void)n    {n      Py_InitModule (&quot;_example&quot;, _example_methods);n    }n  }nn**Aren't you glad you don't have to write something like that everyntime!*</em>nnAdvanced featuresn=================nnSpecifying argumentsn--------------------nnOf course, many plugin methods will need to have arguments.  See thisn``resize_copy`` method, for example:nn.. code:: Pythonnn  # C++ image method with some argumentsn  class resize_copy(PluginFunction):n      &quot;&quot;&quot;n      Copies and resizes an image. In addition to size the type ofn      interpolation can be specified to allow tradeoffs between speedn      and quality.n      &quot;&quot;&quot;n      category = &quot;Utility/Copy&quot;n      self_type = ImageType([ONEBIT, GREYSCALE, GREY16, FLOAT, RGB])n      args = Args([Int(&quot;nrows&quot;), Int(&quot;ncols&quot;),n                  Choice(&quot;Interpolation Type&quot;, [&quot;None&quot;, &quot;Linear&quot;, &quot;Spline&quot;])])n      return_type = ImageType([ONEBIT, GREYSCALE, GREY16, FLOAT, RGB])nnAnd the corresponding C++ declaration:nn.. code:: CPPnn  template&lt;class T&gt;n  Image* resize_copy(T&amp; image, int nrows, int ncols, int resize_quality);nnThe <tt class="docutils literal">args</tt> member variable specifies a list of the arguments thatnare passable to the method.  Note that this does not include the firstn&quot;argument&quot; to the C++ function, which always corresponds ton``self_type``.  This specification is used to generate wrapper code,nand also to generate dialog boxes in the GUI.  The format of thesenargument lists are documented in <a href="#id4"><span class="problematic" id="id8">`Specifying arguments`__</span></a>.nn.. __: args.htmlnnThe <em>args</em> parameter in the plugin prototype allows the specification ofndefault values for arguments. These are however used only in the GUI fornthe argument dialog box. If you need an actual default argument for yournplugin function, you must define the <tt class="docutils literal">__call__</tt> method in your plugin, e.g.nn.. code:: Pythonnn      # wrapper for passing a default argumentn      def __call__(self, nrows, ncols, interpolation=&quot;Linear&quot;):n          return _example.resize_copy(self, nrows, ncols, interpolation)n    __call__ = staticmethod(__call__)nn``_example`` must be replaced by the actual name of your source file plusna leading underscore.nnFree functionsn--------------nnIt doesn't always make sense to have everything be a method of images.nFor example, you may want to create a function that requires a list ofnimages as input.  Fortunately, you can still use the plugin system tonautomate the wrapping/building process, while foregoing the automaticninclusion of the method in the Image class and on the right-clickncontext menu. It's as simple as setting <tt class="docutils literal">self_type</tt> to <tt class="docutils literal">None</tt> innthe metadata object:nn.. code:: Pythonnn  # C++ free functionn  class union_images(PluginFunction):n      &quot;&quot;&quot;n      Creates a new image by overlaying all the images in the given list.n      &quot;&quot;&quot;n      self_type = Nonen      args = Args([ImageList('list_of_images')])n      return_type = ImageType([ONEBIT])nnAs these functions are not image methods, but standalone <em>callable</em> classes,nyou additionally must create an instance of this class in the same pythonnmetadata <a class="reference external" href="file:nn">file:nn</a>.. code:: Pythonnn  union_images = union_images()nnPure Python methodsn-------------------nnSometimes there is not much efficiency to be gained by writing thenplugin method in C++, or you want the flexibility of Python fornexperimentation.  In that case you can implement the method in purenPython.  Everything else is the same, except you add a <tt class="docutils literal">__call__</tt>nmethod with the Python implementation.  It is important that thisnmethod is a <tt class="docutils literal">staticmethod</tt>, since the first <tt class="docutils literal">self</tt> argument isngoing to be an <tt class="docutils literal">Image</tt> object and not a <tt class="docutils literal">PluginFunction</tt> object:nn.. code:: Pythonnn  # Python image methodn  class area(PluginFunction):n      &quot;&quot;&quot;n      Returns the aspect ratio of the bounding box of the image.n      &quot;&quot;&quot;n      self_type = ImageType([ONEBIT, GREYSCALE, GREY16, FLOAT, RGB])n      return_type = Float(&quot;area&quot;)n      pure_python = Truen      def __call__(self):n          return float(self.ncols) / float(self.nrows)n      __call__ = staticmethod(__call__)nnFree pure Python functionsn--------------------------nnSince the plugin modules are also just regular Python modulesnunderneath, it is of course possible to just add ordinary Pythonnfunctions as well:nn.. code:: Pythonnn  # Python free functionn  def filter_small_images(l):n      return [x for x in l if x.ncols &gt; 2 and x.nrows &gt; 2]nnRaising exceptionsn------------------nnThe convention in Gamera is to use exceptions for error conditionsnrather than by using error codes.nnC++ exceptions are automatically propagated to Python.  (All C++nexception types will be converted to Python <tt class="docutils literal">RuntimeError</tt>.)nn.. code:: CPPnn   throw std::runtime_error(&quot;Input is out of range&quot;);nnFrom pure Python functions, the standard Python exception mechanismncan be used:nn.. code:: Pythonnn   raise RuntimeError(&quot;Input is out of range&quot;)nnProgress barsn-------------nnThis section describes how to display a progress bar dialog from anlong-running plugin. When the GUI is running, the progressnwill be displayed in a window:nn  .. image:: images/progress_bar.pngnnIt is also possible to display a progress bar made from text charactersnin the console, when the GUI is not running. To make it appear, setnthe config option <em>progress_bar</em> to <tt class="docutils literal">True</tt> as follows:nn.. code:: Pythonnn   from gamera.config import confign   config.set(&quot;progress_bar&quot;,True)nnProgress bars will add some overhead when displayed, so theynonly make sense for plugins that take a long time to complete.nSupporting progress bars adds very minimal overhead when they are notndisplayed.nnnProgress Bars in Pythonn```````````````````````nnTo create a progress bar that is a message box in the GUI andna text line in a non GUI script, you can use the <tt class="docutils literal">ProgressFactory</tt>:nn.. code:: Pythonnn   from gamera.util import ProgressFactoryn   progress = ProgressFactory(&quot;Title&quot;, length, numsteps=0)nnwhere <em>length</em> is the total number of which the progress fraction is tonbe shown. The optional argument <em>numsteps</em> can be useful to reducenthe overhead by only updating the progress bar in <em>numsteps</em> discrete steps;nwhen zero, every update call will result in an update of the progress bar.nnTo update the progress bar, there are two alternative methods:nnn - <tt class="docutils literal">.step()</tt> increases the progress counter by one. Whether then   displayed progress bar actually is updated depends on <em>numsteps</em>.nn - <tt class="docutils literal">.update(steps, length)</tt> sets the progress bar to then   <em>steps</em>/<em>length</em> fraction.nnnProgress Bars in C++ Pluginsn````````````````````````````nnTo create a plugin method with a progress bar, simply set then``progress_bar`` member to the message that will be displayed in thenprogress box.nn.. code:: Pythonnn  class cc_analysis(Segmenter):n    ...n    progress_bar = &quot;Generating connected components&quot;n    ...nnAdd an extra argument to the C++ function that takes an object of typen``ProgressBar``.  This can be a default argument, to make it easier toncall the plugin function code without requiring a <tt class="docutils literal">ProgressBar</tt> instance.nCreating a <tt class="docutils literal">ProgressBar</tt> with no constructor arguments creates andummy <tt class="docutils literal">ProgressBar</tt> object where all methods are ignored.nn.. code:: CPPnn  template&lt;class T&gt;n  ImageList* cc_analysis(T&amp; image, ProgressBar progress_bar = ProgressBar()) {n    ...n  }nnThe progress bar window will automatically disappear when the function returns.nnThere are essentially two ways to update the progress bar:nn - Call <tt class="docutils literal"><span class="pre">.set_length(*length*)</span></tt> to set the number of steps that will ben   performed, and then call <tt class="docutils literal">.step()</tt> to increase the step.nn - Call <tt class="docutils literal"><span class="pre">.update(*num*,</span> *den*)</tt> to say that <em>num</em> of <em>den</em> stepsn   have completed.  <tt class="docutils literal">.update</tt> is useful when the number of steps cann   not be pre-determined.nnnDocumenting and unit-testing Plugin functionsn---------------------------------------------nnThe docstring of each <tt class="docutils literal">PluginFunction</tt> class is used like a regularnPython docstring, but also has the following advantages in Gamera:n n  - It will be included in the automatically generated HTMLn    documentation.nn  - It is displayed in the Documentation pane in the Gamera shelln    window.nn  - It is displayed in the automatically-generated dialog box for then    plugin.nnThe docstrings should be formatted in <a href="#id11"><span class="problematic" id="id12">reStructuredText_</span></a>, which isnbecoming a de-facto Python standard for documentation, as well asnbeing rather easy to read and use.nn.. _reStructuredText: <a class="reference external" href="http://structuredtext.sourceforge.netnnThe">http://structuredtext.sourceforge.netnnThe</a> Gamera documentation can be regenerated by going to the <tt class="docutils literal">doc</tt>ndirectory (in the source distribution) and running the <tt class="docutils literal">gendoc.py</tt>nscript::nn  python gendoc.pynnIn addition to text, image examples can be generated on-the-fly andnincluded in the documentation using the <tt class="docutils literal">doc_examples</tt> member.  Then``doc_examples`` mechanism is also used to write rudimentarynunit-tests for Gamera's <a href="#id4"><span class="problematic" id="id9">`unit-testing framework`__</span></a>.nn.. __: unit_testing.htmlnnThe <tt class="docutils literal">doc_examples</tt> member is a list of tuples or functions:nn- If the element is a tuple, it is a list of arguments that will ben  passed into the plugin method to create an example.  Where imagen  arguments are expected, image type identifiers can be used, whichn  will load a standard image from disk and use it.  For example::nn    (ONEBIT, 52, 32)nn  will use the standard OneBit image and the arguments of <tt class="docutils literal">52, 32</tt>.nn- If the element is a function, that function will be called to createn  the example.  The function will be passed one argument, <tt class="docutils literal">images</tt>,n  which is a dictionary of the standard Gamera example images.  Anyn  images or values returned will be included in the documentation.n  Any exceptions raised by the function will be logged by then  unit-testing framework when it is run.  For example the followingn  loads the standard RGB and GreyScale images, clips themn  appropriately, adds them together, and then returns all of them forn  inclusion in the documentation.nn.. code:: Pythonnn    def __doc_example1__(images):n        rgb = images[RGB]n        greyscale = images[GREYSCALE]n        clipped = rgb.clip_image(greyscale)n        return [clipped, greyscale, nt        clipped.add_images(greyscale.to_rgb(), False)]n    doc_examples = [__doc_example1__]nnnExamplesn````````nnThe following <tt class="docutils literal">doc_examples</tt> specifier (from <a href="#id13"><span class="problematic" id="id14">simple_sharpen_</span></a>)nproduces two examples, one on the standard GREYSCALE image, andnanother on the standard RGB image, using different values for then*sharpening_factor*.nn.. code:: Pythonnn  doc_examples = [(GREYSCALE, 1.0), (RGB, 3.0)]nn.. _simple_sharpen: convolution.html#simple-sharpennnFor <a href="#id15"><span class="problematic" id="id16">draw_bezier_</span></a>, a custom example function was used, which doesnnot load a standard image.nn.. code:: Pythonnn  def __doc_example1__(images):n      from random import randintn      from gamera.core import Image, Dimn      image = Image((0, 0), Dim(100, 100), RGB, DENSE)n      for i in range(10):n          image.draw_bezier((randint(0, 100), randint(0, 100)),n                            (randint(0, 100), randint(0, 100)),n                            (randint(0, 100), randint(0, 100)),n                            (randint(0, 100), randint(0, 100)),n                            RGBPixel(randint(0, 255), n              t            randint(0,255), n ttt    randint(0, 255)))n      return imagen  doc_examples = [__doc_example1__]nn.. _draw_bezier: draw.html#draw-beziernnnFeature generators: A special kind of pluginn============================================nnPlugin methods that take an image as input and generate some floatingnpoint features from it are called &quot;feature generators&quot;.  The resultingnfloating point features are used by the classifier to classify images.nnFor efficiency reasons, feature generator functions are implementednslightly differently from a regular <tt class="docutils literal">PluginFunction</tt>.  Rather thannreturning the features as a return value, which would require a memoryncopy into the image's feature vector, feature generators writendirectly to a buffer that is passed in as an argument.nnAs an example, let's look at the <tt class="docutils literal">nholes</tt> feature generator.  ThenPython metadata is the same as you would expect, except the membern``feature_function`` is set to <tt class="docutils literal">True</tt>.  This will tell the buildnsystem to treat this plugin method as a feature generator with thendifferent return value behavior.  The <tt class="docutils literal">return_type</tt> must be an``FloatVector``, where <tt class="docutils literal">length</tt> indicates the number of featurenvalues that are generated.nn.. code:: Pythonnn   class nholes(PluginFunction):n       &quot;&quot;&quot;n       Returns the average number of transitions from white to blackn       in each row or column.n   n       The elements of the returned <tt class="docutils literal">FloatVector</tt> are:nn       0. verticaln       1. horizontaln       n       These features are scale invariant.n       &quot;&quot;&quot;n       self_type = ImageType([ONEBIT])n       return_type = FloatVector(length=2)n       feature_function = Truen       doc_examples = [(ONEBIT,)]nnOn the C++ side, the function takes two arguments: the image, and anpointer to a floating point buffer.  Note that the return type is <tt class="docutils literal">void</tt>.nn.. code:: CPPnn  template&lt;class T&gt;n  void nholes(T &amp;m, feature_t* buf) {n    int vert, horiz;n    n    vert = nholes_1d(m.col_begin(), m.col_end());n    horiz = nholes_1d(m.row_begin(), m.row_end());n    n    <em>(buf++) = (feature_t)vert / m.ncols();n    *buf = (feature_t)horiz / m.nrows();n  }nn(The C++ function ``nholes_1d`` is where all the real work gets done,nand is not important for this illustration.)  Note how the result of thenfunction is copied directly into the buffer.  nn.. note:: It is extremely important not to write more values to then  buffer than is defined in the metadata ``return_value``.  Doing son  could cause Python/Gamera to behave erratically or segfault.nnIt is also possible to write a feature generator in pure Python.nn.. code:: Pythonnn   class nholes(PluginFunction):n       self_type = ImageType([ONEBIT])n       return_type = FloatVector(length=2)n       feature_function = Truen       doc_examples = [(ONEBIT,)]nn       def __call__(self, index):n           buffer = self.featuresn       n           # Do some processing to get values...nt                 nt   buffer[index] = result1n           buffer[index + 1] = result2  n       __call__ = staticmethod(__call__)nnnFurther readingn===============nn- `Writing C++ plugin methods that processes Gamera images`__nn.. __: image_api.htmlnn- `Specifying arguments`__nn.. __: args.htmlnn- `Passing/returning custom data types to/from plugins`__nn.. __: plugins_custom_types.htmlnn- `Grouping plugins together into toolkits`__nn.. __: writing_toolkits.htmlnn- And of course, there's lots of examples in the Gamera code itself!nnReferencesn==========nn.. [Stroustrup1997] Stroustrup, B. 1997. *The C++ Programmingn   Language: Third Edition.</em>  Reading, MA: Addison-Wesley.nn'</p>
<div class="system-message" id="id1">
<p class="system-message-title">System Message: ERROR/3 (<tt class="docutils">./src/writing_plugins.txt</tt>, line 1); <em><a href="#id2">backlink</a></em></p>
Unknown interpreted text role &quot;raw-html&quot;.</div>
<div class="system-messages section">
<h1>Docutils System Messages</h1>
<div class="system-message" id="id4">
<p class="system-message-title">System Message: ERROR/3 (<tt class="docutils">./src/writing_plugins.txt</tt>, line 2); <em>backlinks: <a href="#id5">1</a>, <a href="#id6">2</a>, <a href="#id7">3</a>, <a href="#id8">4</a>, <a href="#id9">5</a></em></p>
Anonymous hyperlink mismatch: 5 references but 0 targets.
See &quot;backrefs&quot; attribute for IDs.</div>
<div class="system-message" id="id10">
<p class="system-message-title">System Message: ERROR/3 (<tt class="docutils">./src/writing_plugins.txt</tt>, line 1); <em><a href="#id3">backlink</a></em></p>
Unknown target name: &quot;stroustrup1997&quot;.</div>
<div class="system-message" id="id11">
<p class="system-message-title">System Message: ERROR/3 (<tt class="docutils">./src/writing_plugins.txt</tt>, line 1); <em><a href="#id12">backlink</a></em></p>
Unknown target name: &quot;restructuredtext&quot;.</div>
<div class="system-message" id="id13">
<p class="system-message-title">System Message: ERROR/3 (<tt class="docutils">./src/writing_plugins.txt</tt>, line 1); <em><a href="#id14">backlink</a></em></p>
Unknown target name: &quot;simple_sharpen&quot;.</div>
<div class="system-message" id="id15">
<p class="system-message-title">System Message: ERROR/3 (<tt class="docutils">./src/writing_plugins.txt</tt>, line 1); <em><a href="#id16">backlink</a></em></p>
Unknown target name: &quot;draw_bezier&quot;.</div>
</div>
</div>
</body>
</html>
