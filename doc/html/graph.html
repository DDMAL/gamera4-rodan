<?xml version="1.0" encoding="utf-8" ?>
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml" xml:lang="en" lang="en">
<head>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
<meta name="generator" content="Docutils 0.15.2: http://docutils.sourceforge.net/" />
<title>graph.txt</title>
<link rel="stylesheet" href="default.css" type="text/css" />
</head>
<body>
<div class="document">


<p>b'====================nGamera graph libraryn====================nn**Last modified**: June 03, 2019nn.. contents::nn.. role:: raw-html(raw)n   :format: htmln.. footer:: <a href="#id1"><span class="problematic" id="id2">:raw-html:`&lt;div style=&quot;text-align:right;&quot;&gt;For contact information, see &lt;a href=&quot;http://gamera.informatik.hsnr.de/contact.html&quot;&gt;http://gamera.informatik.hsnr.de/contact.html&lt;/a&gt;&lt;/div&gt;`</span></a>nnnIntroductionn------------nnGamera provides a rudimentary framework for dealing with graphnstructures.  This library can be used from Python and from C++.nnThis chapter assumes a basic understanding of graph theory and graphnalgorithms.   While this document describes the API, itndoes not describe in detail how the algorithms work.  (Hopefully thisncan be added in a future release of this documentation.)nnUsing the graph library from Pythonn-----------------------------------nnMost operations on graphs in the Gamera graph library are methods onn``Graph`` objects.nnEach node is identified by an arbitrary Python value.  <strong>Importantly,nthe same value may not be assigned to more than one node within thensame graph</strong>.  Whenever a node is needed as an argument, either thennode object or the node's value may be passed in.  In most cases, itnis more convenient to refer to nodes by their associated values rathernthan keeping track of their associated <tt class="docutils literal">Node</tt> objects.nnThe following example code covers basic usage.  For more detailedndescriptions of the properties and methods, see the <a href="#id7"><span class="problematic" id="id8">Reference_</span></a> section.nnLet's look at some simple code to create the following trivially smallngraph structure:nn  .. image:: images/graph_example.pngnn.. code:: Pythonnn  &gt;&gt;&gt; from gamera import graphn  &gt;&gt;&gt; from gamera import graph_utiln  &gt;&gt;&gt;n  &gt;&gt;&gt; g = graph.Graph()n  &gt;&gt;&gt;n  &gt;&gt;&gt; g.add_edge('a', 'b')n  1n  &gt;&gt;&gt; g.add_edge('a', 'c')n  1n  &gt;&gt;&gt; g.add_edge('a', 'd')n  1n  &gt;&gt;&gt; g.add_edge('b', 'd')n  1n  &gt;&gt;&gt; g.add_edge('c', 'e')n  1n  &gt;&gt;&gt; g.add_edge('f', 'g')n  1n  &gt;&gt;&gt; g.add_edge('f', 'g')n  1n  &gt;&gt;&gt; g.add_edge('e', 'e')n  1n  &gt;&gt;&gt;nn``add_edge`` creates nodes that don't already exist, so <tt class="docutils literal">add_node</tt>nis not necessary to create this graph.nnThe number of nodes and edges can be queried:nn.. code:: Pythonnn  &gt;&gt;&gt; g.nnodes # Number of nodesn  7n  &gt;&gt;&gt; g.nedges # Number of edgesn  8nnNow, the graph can be traversed, using either a breadth-first searchn(BFS) or depth-first search (DFS).  Each search algorithm takes a nodenas a starting point:nn.. code:: Pythonnn  &gt;&gt;&gt; # node is a Node instance.  Call node() to get its valuen  &gt;&gt;&gt; for node in g.BFS('a'):n  ...    print node(),n  ...n  a b c d en  &gt;&gt;&gt; for node in g.DFS('a'):n  ...    print node(),n  ...n  a d c e bn  &gt;&gt;&gt; # No other nodes reachable from 'e'n  &gt;&gt;&gt; for node in g.BFS('e'):n  ...    print node(),n  ...n  en  &gt;&gt;&gt; for node in g.BFS('f'):n  ...    print node(),n  ...n  f gnnNote that the search algorithms, like many other things in the Gamerangraph library, return lazy iterators, so the results are determined onndemand.  Importantly, this means you cannot get the length of thenresult until it has been entirely evaluated.nn.. code:: Pythonnn  &gt;&gt;&gt; g.BFS('a')n  &lt;gamera.graph.Iterator object at 0xf6fa54d0&gt;n  &gt;&gt;&gt; len(g.BFS('a'))n  Traceback (most recent call last):n    File &quot;&lt;stdin&gt;&quot;, line 1, in ?n  TypeError: len() of unsized objectn  &gt;&gt;&gt; list(g.BFS('a'))n  [&lt;Node of 'a'&gt;, &lt;Node of 'b'&gt;, &lt;Node of 'c'&gt;, &lt;Node of 'd'&gt;, &lt;Node of 'e'&gt;]n  &gt;&gt;&gt; [node() for node in g.BFS('a')]n  ['a', 'b', 'c', 'd', 'e']n  &gt;&gt;&gt;nnNote that this graph is composed of two distinct subgraphs.  There arenways to determine the number of subgraphs and iterate over the rootsnof those subgraphs if the graph is undirected.  For instance, to do a nbreadth-first search of all subgraphs:nn.. code:: Pythonnn  &gt;&gt;&gt; g.make_undirected()n  &gt;&gt;&gt; g.nsubgraphsn  2n  &gt;&gt;&gt; for root in g.get_subgraph_roots():n  ...    for node in g.BFS(root):n  ...       print node.data,n  ...    printn  ...n  a b c d en  f gnnThe graph can be restricted based on a number of differentnproperties by passing flags to the constructor.  These propertiesninclude directedness, cyclicalness, multi-connectedness andnself-connectedness.  (See <a href="#id9"><span class="problematic" id="id10">`Graph constructor`_</span></a>).nnFor instance, let's attempt to make a <em>tree</em>, which is a graph thatnis undirected and contains no cycles, using the same graph structure:nn.. code:: Pythonnn  &gt;&gt;&gt; g = graph.Graph(graph.TREE | graph.CHECK_ON_INSERT)n  &gt;&gt;&gt; g.add_edge('a', 'b')n  1n  &gt;&gt;&gt; g.add_edge('a', 'c')n  1n  &gt;&gt;&gt; g.add_edge('a', 'd')n  1n  &gt;&gt;&gt; g.add_edge('b', 'd')n  0n  &gt;&gt;&gt; g.add_edge('c', 'e')n  1n  &gt;&gt;&gt; g.add_edge('f', 'g')n  1n  &gt;&gt;&gt; g.add_edge('f', 'g')n  0n  &gt;&gt;&gt; g.add_edge('e', 'e')n  0nnNote that some edges were not created, since they would havenviolated the restrictions of a tree.  This isnindicated by the return value of <tt class="docutils literal">add_edge</tt>.  In this case, ourngraph now looks like this:nn.. image:: images/graph_example2.pngnnThe reference section below provides a complete list of the algorithmsnand methods on graph objects.nnReferencen---------nn``Graph`` objectsn'''''''''''''''''nnEach graph is represented by instances of the <tt class="docutils literal">Graph</tt> class.  Allnmodifications to the graph structure, including adding and removing nodes andnedges, is performed through this class.nnBasic methodsn`````````````nn``Graph`` Constructorn&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;nn.. docstring:: gamera.graph Graph nnMethods for Nodesn&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;nn.. docstring:: gamera.graph Graph add_node add_nodes get_node get_nodes has_node remove_node remove_node_and_edgesnnMethods for Edgesn&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;nn.. docstring:: gamera.graph Graph add_edge add_edges get_edges has_edge remove_edge remove_all_edgesnnDirectednessn&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;nn.. docstring:: gamera.graph Graph is_directed is_undirected make_directed make_undirectednnCyclicalnessn&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;n.. docstring:: gamera.graph Graph is_cyclic is_acyclic make_cyclic make_acyclicnnBlob vs. Treen&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;nn.. docstring:: gamera.graph Graph is_tree is_blob make_tree make_blobnnMulti-connectednessn&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;nn.. docstring:: gamera.graph Graph is_multi_connected is_singly_connected make_multi_connected make_singly_connectednnSelf-connectednessn&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;nn.. docstring:: gamera.graph Graph is_self_connected make_self_connected make_not_self_connectednnSubgraphsn&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;nnHere, a &quot;subgraph&quot; is defined as a connected group of nodes.  A graphncontains multiple subgraphs when the graph does not have a single rootnnode from which all other nodes can be reached.nn.. docstring:: gamera.graph Graph get_subgraph_roots size_of_subgraph is_fully_connectednnUtilityn&quot;&quot;&quot;&quot;&quot;&quot;&quot;nn.. docstring:: gamera.graph Graph copy has_flag has_pathnnPropertiesn``````````nn- <em>nnodes</em>: n    The number of nodes in the graph.nn- <em>nedges</em>: n    The number of edges in the graph.nn- <em>nsubgraphs</em>: n    The number of subgraphs.nnnHigh-level algorithmsn`````````````````````nnSearchn&quot;&quot;&quot;&quot;&quot;&quot;nn.. docstring:: gamera.graph Graph BFS DFSnnShortest pathn&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;nn.. docstring:: gamera.graph Graph dijkstra_shortest_path shortest_path dijkstra_all_pairs_shortest_path all_pairs_shortest_pathnnSpanning treesn&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;nn.. docstring:: gamera.graph Graph create_spanning_tree create_minimum_spanning_treennPartitionsn&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;nn.. docstring:: gamera.graph Graph optimize_partitionsnnColorationn&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;nn.. docstring:: gamera.graph Graph colorize get_colornnnnnNode objectsn''''''''''''nnNodes contain a reference to an arbitrary Python value.  Importantly,nthe value is used to identify the node, so the same value may not benassigned to more than one node.  In many cases, it is much more convenient to refernto nodes by their associated values rather than keeping track ofntheir associated <tt class="docutils literal">Node</tt> objects.nnPropertiesn``````````nn- <em>data</em>: n    The value that identifies this node.  (This value can alson    be obtained by &quot;calling&quot; the node as in <tt class="docutils literal">node()</tt>).nn- <em>edges</em>: n    A lazy iterator over the edges pointing out from the node.nn- <em>nodes</em>: n    A lazy iterator over the nodes that can be reached directlyn    (through a single edge) from this node.nn- <em>nedges</em>:n    The number of edges going out from this node.nnEdge objectsn''''''''''''nnMethodsn```````nntraversen&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;nn**traverse** (<em>node</em>)nnReturns the node on the other end of the edge.  (Useful only fornundirected graphs).nnPropertiesn``````````nn- <em>from_node</em>:n    The starting node of this edge.nn- <em>to_node</em>:n    The ending node of this edge.nn- <em>cost</em>:n    The cost associated with traversing this edge (used by algorithmsn    such as <a href="#id11"><span class="problematic" id="id12">create_minimum_spanning_tree_</span></a>).nn- <em>label</em>:n    The label associated with this edge.nnUtilitiesn'''''''''nnThe following functions are available in the <tt class="docutils literal">graph_util</tt> module.nn.. docstring:: gamera.graph_util graphviz_outputnnnImplementation detailsn----------------------nnThere are many ways to represent graphs in memory for differentnapplications.  Unfortunately, this library only uses one, which maynnot be suitable for all applications.  It is as follows:nn  - The graph object contains lists of all nodes and edges.n    Deleting nodes and edges is in linear time.n    n  - The graph contains a hash table from node data to nodes, so given an    particular piece of data associated with a node, the node can ben    looked up in O(ln <em>n</em>) time.nn  - Each node contains an array of coincident edges.  If the graph isn    directed, this includes edges going in and out from the node.nnnnUsing the Graph library from C++n--------------------------------nnThe module <tt class="docutils literal">gamera.graph</tt> is only a thin Python wrapper aroundna C++ class <tt class="docutils literal">Graph</tt>. This can also be used directly in C++ plugins.nnCompilation and linkagen'''''''''''''''''''''''nnThe header file <em>graph.hpp</em> declares the necessary structures innthe namespace <tt class="docutils literal"><span class="pre">Gamera::Graph</span></tt>. It is installed with the other gameranheader files, and can thus be included withnn.. code:: CPPnn   #include &quot;graph/graph.hpp&quot;n   using namespace Gamera::Graph;nnThe tricky part is getting your plugin module to be linked with thenactual graph implementation. This is achieved by adding thensource files to the <tt class="docutils literal">cpp_sources</tt> property in the plugin Python interface.nnIn the gamera core code, the following works:nn.. code:: Pythonnn   class ExampleModule(PluginModule):n       category = &quot;MyPlugins&quot;n       cpp_headers = [&quot;myplugins.hpp&quot;]n       import globn       cpp_sources = glob.glob(&quot;src/graph/<em>.cpp&quot;)n       functions = [myplugin1, myplugin2]n   module = ExampleModule()nnIn a toolkit, this will not work, because the path names innthe ``cpp_sources`` property are relative to the locationnof the *setup.py</em> script. To allow for the use of the Graph C++nclass in toolkits, the source files are installed togethernwith Gamera. You can thus specify this file in <tt class="docutils literal">cpp_sources</tt>nas follows:nn.. code:: Pythonnn   class ExampleModule(PluginModule):n       # ...n       import os, gameran       gamera_root = os.path.dirname(gamera.__file__)n       import globn       cpp_sources = (glob.glob(os.path.join(gamera_root, &quot;src/graph/<em>.cpp&quot;)))n       # ...nnQuerying the Gamera installation directory through the *__file__</em> propertynof the gamera module is safer than using <em>get_python_lib()</em> fromn``distutils.sysconfig``, because it also works when Gamera is notninstalled into the standard location for python extensions.nnnUsagen'''''nnMost methods are similar to them in the Python wrapper. For a detailed ndescription you can see more details in the implementation and header files nof Graph. A node is designed for storing a class derived from GraphData. Be nsure storing your GraphData objects as long as your Graph lives. GraphData ndefines the virtual methods which must be implemented in your derived class.nn  - <strong>virtual GraphData* copy</strong> ()nn    copies a given Data element. Note that this will <em>not</em> be deleted n    automatically.nn  - <strong>virtual int compare</strong> (<em>const GraphData&amp; b</em>)nn    returns 0 if b and \*this are equalnn    returns &lt;0 if \*this &lt; bnn    returns &gt;0 if \*this &gt; bnn    The comparison operators &lt; &gt; == != &lt;= &gt;= are mapped to this method.nnnYou can see some examples for derived classes in <tt class="docutils literal">graphdataderived.hpp</tt>nnnExamplen'''''''nHere is a very short example for a C++-Usage:nn.. code:: CPPnn   #include &quot;graph/graph.hpp&quot;n   n   void test() {n      Graph* g = new Graph(FLAG_UNDIRECTED);n      GraphDataUnsignedInt* data1 = new GraphDataUnsignedInt(42);n      GraphDataUnsignedInt* data2 = new GraphDataUnsignedInt(21);n      n      g-&gt;add_node(data1);n      g-&gt;add_node(data2);n      g-&gt;add_edge(data1, data2, 2.0);nn      delete g;n      delete data1;n      delete data2;n   }nnnIteratorsn'''''''''nnMany methods use lazy iterators as their return value. Here is a small nexample on handling iterators in C++.nn.. code:: CPPnn   Graph* g = new Graph();n   // add nodes and edges to gn   // ...n   NodePtrIterator <a href="#id3"><span class="problematic" id="id4">*</span></a>nit = g-&gt;get_nodes(); //iterator is allocated on heapn   Node <a href="#id5"><span class="problematic" id="id6">*</span></a>n;n   while((n = nit-&gt;next()) != NULL) {n      // next() returns NULL when there are no more elementsn      // You can do something with node n, but do not add or remove n      // nodes to the graph because this would invalidate the iterator.n   }nn   delete nit; //iterator must be deleted after usagenn'</p>
<div class="system-message" id="id1">
<p class="system-message-title">System Message: ERROR/3 (<tt class="docutils">./src/graph.txt</tt>, line 1); <em><a href="#id2">backlink</a></em></p>
Unknown interpreted text role &quot;raw-html&quot;.</div>
<div class="system-message" id="id3">
<p class="system-message-title">System Message: WARNING/2 (<tt class="docutils">./src/graph.txt</tt>, line 1); <em><a href="#id4">backlink</a></em></p>
Inline emphasis start-string without end-string.</div>
<div class="system-message" id="id5">
<p class="system-message-title">System Message: WARNING/2 (<tt class="docutils">./src/graph.txt</tt>, line 1); <em><a href="#id6">backlink</a></em></p>
Inline emphasis start-string without end-string.</div>
<div class="system-messages section">
<h1>Docutils System Messages</h1>
<div class="system-message" id="id7">
<p class="system-message-title">System Message: ERROR/3 (<tt class="docutils">./src/graph.txt</tt>, line 1); <em><a href="#id8">backlink</a></em></p>
Unknown target name: &quot;reference&quot;.</div>
<div class="system-message" id="id9">
<p class="system-message-title">System Message: ERROR/3 (<tt class="docutils">./src/graph.txt</tt>, line 1); <em><a href="#id10">backlink</a></em></p>
Unknown target name: &quot;graph constructor&quot;.</div>
<div class="system-message" id="id11">
<p class="system-message-title">System Message: ERROR/3 (<tt class="docutils">./src/graph.txt</tt>, line 1); <em><a href="#id12">backlink</a></em></p>
Unknown target name: &quot;create_minimum_spanning_tree&quot;.</div>
</div>
</div>
</body>
</html>
