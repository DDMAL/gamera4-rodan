<?xml version="1.0" encoding="utf-8" ?>
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml" xml:lang="en" lang="en">
<head>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
<meta name="generator" content="Docutils 0.15.2: http://docutils.sourceforge.net/" />
<title>geometry.txt</title>
<link rel="stylesheet" href="default.css" type="text/css" />
</head>
<body>
<div class="document">


<p>b'nGeometryn========nn**Last modified**: November 17, 2019nn.. contents::nn.. role:: raw-html(raw)n   :format: htmln.. footer:: <a href="#id1"><span class="problematic" id="id2">:raw-html:`&lt;div style=&quot;text-align:right;&quot;&gt;For contact information, see &lt;a href=&quot;http://gamera.informatik.hsnr.de/contact.html&quot;&gt;http://gamera.informatik.hsnr.de/contact.html&lt;/a&gt;&lt;/div&gt;`</span></a>nnn``convex_hull_as_image``n------------------------nn``Image`` [OneBit] <strong>convex_hull_as_image</strong> (<tt class="docutils literal">bool</tt> <em>filled</em> = False)nnn:Operates on: <tt class="docutils literal">Image</tt> [OneBit]n:Returns: <tt class="docutils literal">Image</tt> [OneBit]n:Category: Geometryn:Defined in: geometry.pyn:Author: Christoph DalitznnnReturns an image containing the polygon of the convex hull calculatednby <a href="#id16"><span class="problematic" id="id17">convex_hull_as_points_</span></a>.nn.. _convex_hull_as_points: geometry.html#convex_hull_as_pointsn   nn----------nn**Example 1:** convex_hull_as_image()nn..  image:: images/OneBit_generic.pngn   :height: 99n   :width: 69nn..  image:: images/convex_hull_as_image_plugin_00.pngn   :height: 99n   :width: 69nnnn``convex_hull_as_points``n-------------------------nn[object] <strong>convex_hull_as_points</strong> ()nnn:Operates on: <tt class="docutils literal">Image</tt> [OneBit]n:Returns: [object]n:Category: Geometryn:Defined in: geometry.pyn:Author: Christoph DalitznnnReturns the vertex points of the convex hull of all black pixelsnin the given image.nnActually not all black pixels are required for computing the convex hull,nbut only the left and right contour pixels of the image. This followsnfrom the fact that, when a point is invisible both from the left and thenright, it lies on the connection axis between two visible points and thusncannot be a vertex point of the convex hull.n   nnn``convex_hull_from_points``n---------------------------nn[object] <strong>convex_hull_from_points</strong> ([object <em>points</em>])nnn:Returns: [object]n:Category: Geometryn:Defined in: geometry.pyn:Author: Christian Brandt, Christoph Dalitz, and David KolanusnnnReturns the polygon vertices of the convex hull of the given list ofnpoints.nnThe function uses Graham's scan algorithm as described e.g. in Cormen et al.:n*Introduction to Algorithms.* 2nd ed., MIT Press, p. 949, 2001nnnn``delaunay_from_points``n------------------------nnobject <strong>delaunay_from_points</strong> ([object <em>points</em>], <tt class="docutils literal">IntVector</tt> <em>labels</em>)nnn:Returns: objectn:Category: Geometryn:Defined in: geometry.pyn:Author: Oliver Christen (based on code by Olivier Devillers)nnnComputes the Delaunay triangulation directly from a list of points andnpoint labels. The result is a list which contains tuples of adjacent labels,nwhere in each tuple the smaller label is given first.nnThe arguments <em>points</em> and <em>labels</em> specify the points and nonnegativenlabels, such that <tt class="docutils literal">labels[i]</tt> is the label of <tt class="docutils literal">points[i]</tt>. Note thatnthe labels need not necessarily all be different, which can be usefulnfor the computation of a neighborship graph from a set of connectedncomponents.nnThe computation of the Delaunay triangulation is based on the Delaunayntree which is a randomized geometric data structure. It isndescribed in O. Devillers, S. Meiser, M. Teillaud:n`Fully dynamic Delaunay triangulation in logarithmic expected time per operation.`__nComputational Geometry: Theory and Applications 2, pp. 55-80, 1992.nn.. __: <a class="reference external" href="http://hal.inria.fr/inria-00090678nnThis">http://hal.inria.fr/inria-00090678nnThis</a> can be useful for building a neighborhood graph as shown in thenfollowing example:nn.. code:: Pythonnn  from gamera import graphn  from gamera.plugins.geometry import delaunay_from_pointsn  n  points = [(10,10),(20,30),(32,22),(85,14),(40,70),(80,85)]n  labels = range(len(points))n  neighbors = delaunay_from_points(points, labels)n  n  g = graph.Graph(graph.UNDIRECTED)n  for pair in neighbors:n      g.add_edge(pair[0], pair[1])nnn``hough_lines``n---------------nnobject <strong>hough_lines</strong> ([object <em>points</em>], float <em>theta_min</em>, float <em>theta_step</em>, float <em>theta_max</em>, float <em>rho_min</em>, float <em>rho_step</em>, float <em>rho_max</em>, int <em>n_lines</em>, float <em>threshold</em>)nnn:Returns: objectn:Category: Geometryn:Defined in: geometry.pyn:Author: Manuel Jeltsch and Christoph DalitznnnFinds lines in a point set with the Hough transform. Lines are nrepresented by the Hessian normal form, i.e. by the two parametersn*theta* and <em>rho</em>, where <em>rho</em> is the distance of the line to the origin,nand <em>theta</em> is the angle of normal; a horizontal line thereforenhas <em>theta</em> = 90 degrees.nnThe found lines are returned as a list of tuples n[(<em>votes</em>, <em>theta</em>, <em>rho</em>),...],nwhere <em>votes</em> is the number of points from the point set belonging tonthis line. The lines are sorted by <em>votes</em> in descending order. Which andnhow many lines are returned is controlled with <em>threshold</em> and <em>n_lines</em>.nThe angles <em>theta</em> are given in degrees.nnArguments:nn*points*:n    The points from the point cloud.nn*theta_min*, <em>theta_step</em>, <em>theta_max</em>n    Theta-quantization of the Hough space, i.e. the range of anglesn    to be tested. Angles are spezified in degrees.nn*rho_min*, <em>rho_step</em>, <em>rho_max</em>n    Rho-quantization of the Hough space, i.e. the range of origin-distancesn    to be tested.nn*n_lines*n    The number of highest votes lines that are returned. When set ton    zero, all found lines are returned.nn*threshold*n    Only lines with more votes (points) than <em>threshold</em> are returned.nnn``labeled_region_neighbors``n----------------------------nnobject <strong>labeled_region_neighbors</strong> (<tt class="docutils literal">bool</tt> <em>eight_connectivity</em> = True)nnn:Operates on: <tt class="docutils literal">Image</tt> [OneBit]n:Returns: objectn:Category: Geometryn:Defined in: geometry.pyn:Author: Christoph DalitznnnFor an image containing labeled regions, a list of all label pairs belongingnto touching regions is returned. When <em>eight_connectivity</em> is <tt class="docutils literal">True</tt>n(default), 8-connectivity is used for neighborship, otherwisen4-connectivity is used.nnThis can be useful for building a Delaunay graph from a Voronoi tesselationnas in the following example:nn.. code:: Pythonnn  #n  # build Delaunay graph of neighboring (i.e. adjacent) Cc'sn  #nn  # create map label-&gt;Cc for faster lookup latern  ccs = image.cc_analysis()n  label_to_cc = {}n  for c in ccs:n     label_to_cc[c.label] = cnn  # compute area Voronoi tesselation and neighborship listn  voronoi = image.voronoi_from_labeled_image()n  labelpairs = voronoi.labeled_region_neighbors()nn  # build map of all neighbors for each label for fast lookupn  neighbors = {}n  for label in label_to_cc.keys():n     neighbors[label] = []n  for n in labelpairs:n     neighbors[n[0]].append(n[1])n     neighbors[n[1]].append(n[0])nn  # now, all neighbors to a given cc can be looked up withn  neighbors_of_cc = [label_to_cc[label] for label in neighbors[cc.label]]nnn``max_empty_rect``n------------------nn``Rect`` <strong>max_empty_rect</strong> ()nnn:Operates on: <tt class="docutils literal">Image</tt> [OneBit]n:Returns: <tt class="docutils literal">Rect</tt>n:Category: Geometryn:Defined in: geometry.pyn:Author: Daveed Vandevoorde and Christoph DalitznnnReturns the maximum area empty rect that fits into the image withoutncontaining any of the black image pixels. This problem is in the literaturengenerally known as the <em>Largest Empty Rectangle Problem</em>.nnWhen the image does not contain a white pixel at all, an exception of typen``RuntimeError`` is thrown. The coordinates of the returned rectangle arenrelative to the upper left corner of the image.nnReference: D. Vandevoorde: <a href="#id13"><span class="problematic" id="id14">`&quot;The Maximal Rectangle Problem.&quot;`__</span></a> Dr. Dobb's,nApril 1998.nn.. __: <a class="reference external" href="http://www.drdobbs.com/database/184410529n">http://www.drdobbs.com/database/184410529n</a>   nn----------nn**Example 1:** max_empty_rectnn|max_empty_rect_plugin_00_00| nn.. <a href="#id3"><span class="problematic" id="id4">|max_empty_rect_plugin_00_00|</span></a> image:: images/max_empty_rect_plugin_00_00.pngn   :height: 90n   :width: 90nnnn``voronoi_from_labeled_image``n------------------------------nn``Image`` [OneBit|GreyScale] <strong>voronoi_from_labeled_image</strong> ()nnn:Operates on: <tt class="docutils literal">Image</tt> [OneBit|GreyScale]n:Returns: <tt class="docutils literal">Image</tt> [OneBit|GreyScale]n:Category: Geometryn:Defined in: geometry.pyn:Author: Christoph Dalitz, based on code by Ullrich Kxc3xb6thennnComputes the area Voronoi tesselation from an image containing labelednCc's. In the returned onebit image, every pixel is labeled with thenlabel value of the closest Cc in the input image.nnTo prepare the input image, you can use <a href="#id13"><span class="problematic" id="id15">cc_analysis__</span></a>. When the Cc'snonly consist of single points, the area Voronoi tesselation is identicalnto the ordinary Voronoi tesselation.nn.. __: segmentation.html#cc-analysisnnThe implementation applies a watershed algorithm to the distance transformnof the input image, a method known as <em>seeded region growing</em> (U. Kxc3xb6the:n*Primary Image Segmentation.* Proceedings 17th DAGM-Symposium, pp. 554-561,nSpringer, 1995).nnThe example shown below is the image <em>voronoi_cells</em> as created withnthe following code:nn.. code:: Pythonnn  # create an area Voronoi tesselation andn  # mark the cells and their edges in colorn  ccs = image.cc_analysis()  # labels the imagen  voronoi = image.voronoi_from_labeled_image()n  voronoi_cells = voronoi.color_ccs()n  voronoi_cells.highlight(image, RGBPixel(0,0,0))n  voronoi_edges = voronoi.labeled_region_edges()n  voronoi_cells.highlight(voronoi_edges, RGBPixel(255,255,255))nn----------nn**Example 1:** voronoi_from_labeled_imagenn|voronoi_from_labeled_image_plugin_00_00| <a href="#id5"><span class="problematic" id="id6">|voronoi_from_labeled_image_plugin_00_01|</span></a> nn.. <a href="#id7"><span class="problematic" id="id8">|voronoi_from_labeled_image_plugin_00_00|</span></a> image:: images/voronoi_from_labeled_image_plugin_00_00.pngn   :height: 99n   :width: 69nn.. <a href="#id9"><span class="problematic" id="id10">|voronoi_from_labeled_image_plugin_00_01|</span></a> image:: images/voronoi_from_labeled_image_plugin_00_01.pngn   :height: 99n   :width: 69nnnn``voronoi_from_points``n-----------------------nn**voronoi_from_points** ([object <em>points</em>], <tt class="docutils literal">IntVector</tt> <em>labels</em>)nnn:Operates on: <tt class="docutils literal">Image</tt> [OneBit|GreyScale]n:Category: Geometryn:Defined in: geometry.pyn:Author: Christoph DalitznnnComputes the Voronoi tesselation from a list of points and point labels.nThe result is directly written to the input image. Each white pixel isnlabeled with the label value of the closest point. Non white pixel in theninput image are not overwritten.nnThe arguments <em>points</em> and <em>labels</em> specify the points and labels, suchnthat <tt class="docutils literal">labels[i]</tt> is the label of <tt class="docutils literal">points[i]</tt>. Note that the labelsnneed not necessarily all be different, which can be useful as an napproximation of an area Voronoi tesselation.nnThe algorithm is very simple: it stores the points in a <a class="reference internal" href="#kd-tree">kd-tree</a> andnthen looks up the closest point for each image pixel. This has a runtimenof <em>O(N log(n))</em>, where <em>N</em> is the number of image pixels and <em>n</em> is thennumber of points. For not too many points, this should be faster than thenmorphological region growing approach of <a class="reference internal" href="#voronoi-from-labeled-image">voronoi_from_labeled_image</a>.nn.. <span class="target" id="kd-tree">kd-tree</span>: kdtree.htmln.. <span class="target" id="voronoi-from-labeled-image">voronoi_from_labeled_image</span>: #voronoi-from-labeled-imagennThe example shown below is the image <em>voronoi_edges</em> as created withnthe following code:nn.. code:: Pythonnn  # create a Voronoi tesselation and markn  # the cell edges in a second imagen  points = [(10,10),(20,30),(32,22),(85,14),(40,70),(80,85)]n  voronoi = Image((0,0),(90,90))n  voronoi.voronoi_from_points(points,[i+2 for i in range(len(points))])n  voronoi_edges = voronoi.labeled_region_edges()n  for p in points:n     voronoi_edges.set(p,1)nn----------nn**Example 1:** voronoi_from_pointsnn|voronoi_from_points_plugin_00_00| nn.. <a href="#id11"><span class="problematic" id="id12">|voronoi_from_points_plugin_00_00|</span></a> image:: images/voronoi_from_points_plugin_00_00.pngn   :height: 90n   :width: 90nnnn'</p>
<div class="system-message" id="id1">
<p class="system-message-title">System Message: ERROR/3 (<tt class="docutils">./src/geometry.txt</tt>, line 1); <em><a href="#id2">backlink</a></em></p>
Unknown interpreted text role &quot;raw-html&quot;.</div>
<div class="system-messages section">
<h1>Docutils System Messages</h1>
<div class="system-message" id="id3">
<p class="system-message-title">System Message: ERROR/3 (<tt class="docutils">./src/geometry.txt</tt>, line 1); <em><a href="#id4">backlink</a></em></p>
Undefined substitution referenced: &quot;max_empty_rect_plugin_00_00&quot;.</div>
<div class="system-message" id="id5">
<p class="system-message-title">System Message: ERROR/3 (<tt class="docutils">./src/geometry.txt</tt>, line 1); <em><a href="#id6">backlink</a></em></p>
Undefined substitution referenced: &quot;voronoi_from_labeled_image_plugin_00_01&quot;.</div>
<div class="system-message" id="id7">
<p class="system-message-title">System Message: ERROR/3 (<tt class="docutils">./src/geometry.txt</tt>, line 1); <em><a href="#id8">backlink</a></em></p>
Undefined substitution referenced: &quot;voronoi_from_labeled_image_plugin_00_00&quot;.</div>
<div class="system-message" id="id9">
<p class="system-message-title">System Message: ERROR/3 (<tt class="docutils">./src/geometry.txt</tt>, line 1); <em><a href="#id10">backlink</a></em></p>
Undefined substitution referenced: &quot;voronoi_from_labeled_image_plugin_00_01&quot;.</div>
<div class="system-message" id="id11">
<p class="system-message-title">System Message: ERROR/3 (<tt class="docutils">./src/geometry.txt</tt>, line 1); <em><a href="#id12">backlink</a></em></p>
Undefined substitution referenced: &quot;voronoi_from_points_plugin_00_00&quot;.</div>
<div class="system-message" id="id13">
<p class="system-message-title">System Message: ERROR/3 (<tt class="docutils">./src/geometry.txt</tt>, line 2); <em>backlinks: <a href="#id14">1</a>, <a href="#id15">2</a></em></p>
Anonymous hyperlink mismatch: 2 references but 0 targets.
See &quot;backrefs&quot; attribute for IDs.</div>
<div class="system-message" id="id16">
<p class="system-message-title">System Message: ERROR/3 (<tt class="docutils">./src/geometry.txt</tt>, line 1); <em><a href="#id17">backlink</a></em></p>
Unknown target name: &quot;convex_hull_as_points&quot;.</div>
</div>
</div>
</body>
</html>
