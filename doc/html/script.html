<?xml version="1.0" encoding="utf-8" ?>
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml" xml:lang="en" lang="en">
<head>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
<meta name="generator" content="Docutils 0.15.2: http://docutils.sourceforge.net/" />
<title>script.txt</title>
<link rel="stylesheet" href="default.css" type="text/css" />
</head>
<body>
<div class="document">


<p>b'===================================nGetting started with Gamera scriptsn===================================nn**Last modified**: June 03, 2019nn.. contents::nn.. role:: raw-html(raw)n   :format: htmln.. footer:: <a href="#id1"><span class="problematic" id="id2">:raw-html:`&lt;div style=&quot;text-align:right;&quot;&gt;For contact information, see &lt;a href=&quot;http://gamera.informatik.hsnr.de/contact.html&quot;&gt;http://gamera.informatik.hsnr.de/contact.html&lt;/a&gt;&lt;/div&gt;`</span></a>nnnOverviewn--------nnWhile the GUI is great for experimentation, the ultimate goal of anynGamera application is usually an automated application, or script.nThis provides, among other things, the ability to run unattended innbatch mode.nnGamera scripts are merely Python scripts (modules) that use Gameranobjects and call Gamera functions.  The Python language, being anfeature-rich general purpose language, provides a number of ways tonstructure your application.  The high-level structure of yournapplication will largely depend on its size and complexity and yournown programming preferences and style, and is out of the scope of thisndocument.  Obtaining some level of familiarity with Python throughnany of the numerous <a href="#id7"><span class="problematic" id="id8">`Python books and tutorials`__</span></a> available isnrecommended.nn.. __: <a class="reference external" href="http://www.python.org/cgi-bin/moinmoin/PythonBooksnnThe">http://www.python.org/cgi-bin/moinmoin/PythonBooksnnThe</a> examples below demonstrate how to start creating Gamera-basednapplications.  The source code of these examples are available in thenexamples directory of the Gamera distribution.  Each example builds onnthe previous one.nnHello, world!n-------------nnTo use Gamera in a Python script, you simply need to import then``gamera.core`` module and then initialize it:nn.. code:: Pythonnn   from gamera.core import <em>n   init_gamera()nnAfter that, you can use Gamera's functions and methods.  The followingncode loads a given file specified on the command line, converts it tona one-bit (binary) image, and then saves the result to &quot;output.png&quot;.nn.. code:: Pythonnn   import sysnn   # Import the Gamera core and initialize itn   from gamera.core import *n   init_gamera()nn   # Load filename specified on the command line.n   # load_image is a Gamera function to load a TIFF or PNG file.n   # sys.argv is the Pythonic way to access commandline arguments.n   # (A better way to deal with commandline arguments in Pythonn   # is the optparse module, but that's too much detail for thisn   # example...)n   image = load_image(sys.argv[-1])nn   # The variable 'image' now is a reference to the imagenn   # Convert the image to onebit using the default Otsu methodn   onebit = image.to_onebit()nn   # Save the result to a PNG filen   onebit.save_PNG(&quot;output.png&quot;)nnThat's about as simple as it gets with Gamera, but clearly only aboutnas useful as the ubiquitous &quot;Hello, World!&quot; you see in programming texts.nnUsing the GUI from your scriptsn-------------------------------nnFor interactive use, it may be desirable to have the results of anscript displayed in a window, rather than saved to a file.  (If you donnot wish to do this, you can safely skip this section.)  This imagenwindow will have all of the panning and zooming functionality of thenregular Gamera image window, but it will not be possible to use thenright-click menu to perform further updates to the image.nnUsing the GUI for a script is convenient, though slightly tricky forntwo reasons:nn1. Any code that displays images or otherwise interacts with the GUIn   must run inside the GUI thread.  The simplest way to do this is ton   do all work inside of a function, and then pass this functionn   as an argument to ``gui.run()``.  This will have the GUI start then   application once it has been initialized.nn2. One must be careful about the lifetime of image objects.  Since Pythonn   uses reference counting for memory management, whenever there aren   no longer any references pointing to an image object, it isn   automatically deleted.  Whenever ann   image object is deleted, the window is destroyed as well.  So ton   keep windows open for viewing after processing isn   finished, there needs to be at least one reference remaining.  Then   simplest way to do this is to assign the image to a global variable.nnThe following is the same as the previous example, except rather thannsaving the result to disk, it is displayed in a Gamera display window.nn.. code:: Pythonnn   import sysnn   def my_application():n      # Make the image variable a global variablen      # IF YOU DON'T DO THIS, THE WINDOW WILL DISAPPEAR!n      global imagenn      # Load the imagen      image = load_image(sys.argv[-1])nn      # Display the image in a windown      image.display()nn   # Import the Gamera core and initialize itn   from gamera.core import *n   init_gamera()nn   # Import the Gamera GUI and start itn   from gamera.gui import guin   gui.run(my_application)nn   # The GUI thread will automatically stop when all windows haven   # been closed.n   print &quot;Goodbye!&quot;nnUsing the classifiern--------------------nnOne of Gamera's core features is the classifier, which allowsnindividual images to be classified based on some training.  Thenclassifier is described in detail in `the classifier documentation`__.nn.. __: classify.htmlnnThe following is an example that loads an image and classifies itsnconnected components based on a given training set.  Some trainingndata for what is expected in the image is required in order for thisnexample to work correctly.nn.. code:: Pythonnn   import sysnn   def my_application():n      global ccsnn      # Load the image, and convert it to onebitn      image = load_image(sys.argv[-1])n      onebit = image.to_onebit()nn      # Get the connected components from the imagen      ccs = onebit.cc_analysis()nn      # Classify the cc'sn      classifier.classify_list_automatic(ccs)nn      # Display the ccs to show their classificationn      display_multi(ccs)nn   # Import the Gamera core and initialize itn   from gamera.core import *n   init_gamera()nn   # Import the classifier modulen   from gamera import knnn   # Create a new classifiern   classifier = knn.kNNInteractive()n   # Load some training datan   classifier.from_xml_filename(&quot;training.xml&quot;)nn   # Import the Gamera GUI and start itn   from gamera.gui import guin   gui.run(my_application)nnAdvanced use of the classifiern------------------------------nnThere are a couple of downsides to using the classifier as describednin the previous section:nn- The classifier may not be as accurate as possiblenn- Loading the XML file every time the script starts up can be timen  consuming.nnIf one is willing to give up the ability to add more elements to thentraining set at runtime, both of these problems can be ameliorated.nnOnce you have the serialized version of the classifier, it can benloaded easily from your production script:nn.. code:: Pythonnn   from gamera.core import *n   init_gamera()nn   from gamera import knnnn   # Load the classifier from the binary formatn   classifier = knn.kNNNonInteractive(&quot;training.knn&quot;)nn   # Then, we can use the classifier as we otherwise would...nn   # Load the image, and convert it to onebitn   image = load_image(sys.argv[-1])n   onebit = image.to_onebit()nn   # Get the connected components from the imagen   ccs = onebit.cc_analysis()nn   # Classify the cc'sn   classifier.classify_list_automatic(ccs)nn   ...nnDealing with command line optionsn---------------------------------nnThird party scripts are free to deal with command line arguments asnthey wish.  For instance, the Python standard library has two modulesnfor parsing command line arguments, ``getopt`` (deprecated) andn``optparse``.nnOf course, this freedom means that Gamera will ignore its own commandnline arguments when run from scripts.  There are two ways to deal withnthis problem:nn  1. explicitly tell Gamera to parse the command line argumentsnn  2. programmatically set Gamera optionsnnHaving Gamera parse the command linen````````````````````````````````````nnGenerally, if your script would rather ignore the command line andnpass all command line arguments verbatim to Gamera, simply do thenfollowing near the top of the script, but *after</em> importing Gamera:nn.. code:: Pythonnn  from gamera.core import <a href="#id3"><span class="problematic" id="id4">*</span></a>n  import sysn  from gamera.config import confign  config.parse_args(sys.argv[1:])nnAlternatively, you can send &quot;fake&quot; command line arguments for Gameranto parse:nn.. code:: Pythonnn  from gamera.core import <a href="#id5"><span class="problematic" id="id6">*</span></a>n  from gamera.config import confign  config.parse_args([&quot;--progress-bar&quot;])nnProgrammatically setting optionsn````````````````````````````````nnGamera also provides an API to set its options that normally wouldncome from the command line.  Simply use the <tt class="docutils literal">set</tt> method on then``config`` object.nnFor example,nn.. code:: Pythonnn  from gamera.config import confign  config.set(&quot;progress_bar&quot;, True)nnis directly equivalent to the following command line::nn  gamera_gui --progress-barnnNote that the name of the command line argument is changed to be anvalid Python identifier name when used with the <tt class="docutils literal">.set</tt> method: thenhyphens (<tt class="docutils literal">-</tt>) have been replaced by underscores (<tt class="docutils literal">_</tt>).  This is thenstandard behavior of <tt class="docutils literal">optparse</tt>, the command line parsing modulenthat Gamera uses.nnWhere to go from heren---------------------nnObviously, there's a lot more to Gamera that isn't covered in thisnchapter.  Where you go from here is largely dependent on thenparticular document domain.  Most of the work in many Gameranapplications involves analysing the positional information, symbolicnclassification and features of the connected components to recognizenstructure and semantics of the image.nnA good example of how to put these things together is inn``roman_text.py``, which puts simple left-to-right, top-to-bottomnprinted text into its reading order.nn'</p>
<div class="system-message" id="id1">
<p class="system-message-title">System Message: ERROR/3 (<tt class="docutils">./src/script.txt</tt>, line 1); <em><a href="#id2">backlink</a></em></p>
Unknown interpreted text role &quot;raw-html&quot;.</div>
<div class="system-message" id="id3">
<p class="system-message-title">System Message: WARNING/2 (<tt class="docutils">./src/script.txt</tt>, line 1); <em><a href="#id4">backlink</a></em></p>
Inline emphasis start-string without end-string.</div>
<div class="system-message" id="id5">
<p class="system-message-title">System Message: WARNING/2 (<tt class="docutils">./src/script.txt</tt>, line 1); <em><a href="#id6">backlink</a></em></p>
Inline emphasis start-string without end-string.</div>
<div class="system-messages section">
<h1>Docutils System Messages</h1>
<div class="system-message" id="id7">
<p class="system-message-title">System Message: ERROR/3 (<tt class="docutils">./src/script.txt</tt>, line 2); <em><a href="#id8">backlink</a></em></p>
Anonymous hyperlink mismatch: 1 references but 0 targets.
See &quot;backrefs&quot; attribute for IDs.</div>
</div>
</div>
</body>
</html>
