<?xml version="1.0" encoding="utf-8" ?>
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml" xml:lang="en" lang="en">
<head>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
<meta name="generator" content="Docutils 0.15.2: http://docutils.sourceforge.net/" />
<title>plugins_custom_types.txt</title>
<link rel="stylesheet" href="default.css" type="text/css" />
</head>
<body>
<div class="document">


<p>b'============================nCustom data types in pluginsn============================nn**Last modified**: September 03, 2019nn.. contents::nn.. role:: raw-html(raw)n   :format: htmln.. footer:: <a href="#id1"><span class="problematic" id="id2">:raw-html:`&lt;div style=&quot;text-align:right;&quot;&gt;For contact information, see &lt;a href=&quot;http://gamera.informatik.hsnr.de/contact.html&quot;&gt;http://gamera.informatik.hsnr.de/contact.html&lt;/a&gt;&lt;/div&gt;`</span></a>nnnIntroductionn============nnFor common datatypes like <em>Float</em> or <em>PointVector</em>, the GameranC++/Python argument passing interface provides an automatic wrappingnmechanism that is described in <a href="#id3"><span class="problematic" id="id4">`Specifying arguments for plugin\ngeneration and dialog boxes`__</span></a>.nn.. __: args.htmlnnOccasionally, these built in data types are not sufficient, and younneed to pass custom types. A typical situation is that your returnntype is a tuple.nnnAn examplen==========nnAssume we need a plugin <em>grey_stats</em> that returns both the mean grey valuenand its variance on a greyscale image. As the return value is a tuplenof two values, we cannot use one of the built in data types.nnWe therefore use the generic argument type <tt class="docutils literal">Class</tt> in thenPython wrapper for our plugin. Note that it is a good idea tongive more information about the actual return value(s) in thendocumentation string:nn.. code:: Pythonnn  class grey_stats(PluginFunction):n     &quot;&quot;&quot;Returns mean and variance of the grey values as a tuple <em>(m,var)</em>&quot;&quot;&quot;n     self_type = ImageType([GREYSCALE])n     return_type = Class(&quot;m_var&quot;)nnOn the C++ side, the return type is <tt class="docutils literal">PyObject*</tt> and can be constructednwith any of the conversion functions from the Python C API, e.g. n``Py_BuildValue``:nn.. code:: CPPnn  template&lt;class T&gt;n    PyObject* grey_stats(const T &amp;img) {n    size_t i;n    double Ex = 0.0;  // E(X)n    double Ex2 = 0.0; // E(X^2)n    FloatVector* hist = histogram(img);n    for (i=0; i &lt; hist-&gt;size(); i++) {n      Ex  += i * (<em>hist)[i];n      Ex2 += i*i * (*hist)[i];n    }n    delete hist;n    return Py_BuildValue(&quot;ff&quot;, Ex, Ex2 - Ex*Ex);n  }nnIn a Python script, the plugin can be called withnn.. code:: Pythonnn  (m,v) = img.grey_stats()n  # or:n  m,v = img.grey_stats()nnIt is also possible to call the plugin from the C++ side, by simplynconverting the ``PyObject*`` return value back to C++ data types:nn.. code:: CPPnn  double m,v;n  PyObject</em> obj;n  obj = grey_stats(img);n  PyArg_ParseTuple(obj, &quot;ff&quot;, &amp;m, &amp;v);n  Py_DECREF(obj);nnThe last line is necessary to avoid a memory leak. The <tt class="docutils literal">Py_BuildValue</tt>nfunction returns an <a href="#id3"><span class="problematic" id="id5">`&quot;owned reference&quot;`__</span></a> (in Python lingo), which means thatnit has increased its reference count. To allow the PyObject to be deletednby the Python runtime library, its reference count must be decreasednagain. The actual deletion of the PyObject will then occur at some pointnin the future by the Python garbage collector.nn.. __: <a class="reference external" href="http://docs.python.org/extending/extending.html#ownership-rulesnnnReceiving">http://docs.python.org/extending/extending.html#ownership-rulesnnnReceiving</a> a custom type in C++n==============================nnWhen you have a <tt class="docutils literal">PyObject*</tt> as an input argument of a plugin function,nyou can convert it to C++ data types with the conversion functions fromnthe <a href="#id3"><span class="problematic" id="id6">`Python C API`__</span></a>. These arenn * <tt class="docutils literal">PyLong_AsLong</tt> and colleagues for ordinary scalar data typesnn * <tt class="docutils literal">PyArg_ParseTuple</tt> for tuplesnn * <tt class="docutils literal">PyList_GetItem</tt> for listsnn * <tt class="docutils literal">PyObject_GetAttrString</tt> for properties of arbitrary classesnn.. __: <a class="reference external" href="http://docs.python.org/c-api/nnA">http://docs.python.org/c-api/nnA</a> fundamental problem with the conversion from PyObjects is that youncan never be sure what actually is in the <tt class="docutils literal">PyObject*</tt>. For instance,nwhen you expect a list and apply <tt class="docutils literal">PyList_GetItem</tt>, you cannot be surenthat the <tt class="docutils literal">PyObject*</tt> actually is a list. Nor can you safely assume thatnthe list entries are of the data type you believe them to be. It is thusngenerally a good idea to check data types with <tt class="docutils literal">PyList_Check</tt> and n``PyObject_TypeCheck``, and to throw an exception when the wrong datantype enters your function, e.g.nn.. code:: CPPnn  PyObject* myplugin(PyObject* list) {n    if(!PyList_Check(list))n      throw std::runtime_error(&quot;myplugin: Input argument is no list.&quot;);n    // ...n  }nnnReturning a custom type from C++n================================nnTo return a <tt class="docutils literal">PyObject*</tt> from a plugin function,nyou can use the conversion functions fromnthe <a href="#id3"><span class="problematic" id="id7">`Python C API`__</span></a>. These arenn * <tt class="docutils literal">Py_BuildValue</tt> for tuples or ordinary scalar values;n   as for all common scalar data types the Gamera argument wrappingn   can be used, calling Py_BuildValue for scalar types is usuallyn   only necessary for creating PyObjects for passing ton   returned lists or custom class properties.nn * <tt class="docutils literal">PyList_New</tt> and <tt class="docutils literal">PyList_SetItem</tt> for listsnn * <tt class="docutils literal">PyInstance_New</tt> and <tt class="docutils literal">PyObject_SetAttrString</tt> for arbitrary classesnn.. __: <a class="reference external" href="http://docs.python.org/c-api/nnPyObjects">http://docs.python.org/c-api/nnPyObjects</a> returned from a plugin function must always be n`&quot;owned references&quot;<cite>__. As both ``Py_Build_Value`</cite> and <tt class="docutils literal">PyList_New</tt>ncreate owned references, this is usually automatically fulfilled.nThere is however one special case when you read a list entry fromnan input list with <tt class="docutils literal">PyList_GetItem</tt> and write it to a return listnwith <tt class="docutils literal">PyList_SetItem</tt>. As <tt class="docutils literal">PyList_GetItem</tt> yields a &quot;borrowednreference&quot;, its reference count must be increased if it is to benreturned to Python. Here is an example that returns half of the inputnsequence and fills the rest with zeros:nn.. __: http://docs.python.org/extending/extending.html#ownership-rulesnn.. code:: CPPnn  PyObject* myplugin(PyObject* list) {n    size_t n,i;n    PyObject <em>retval, *entry;n    n = PyList_Size(list);n    retval = PyList_New(n);n    for (i=0; i&lt;n/2; i++) {n      // PyList_GetItem returns a borrowed referencen      // =&gt; reference count must be manually increased (Py_SetItem does not do so)n      entry = PyList_GetItem(list, i);n      Py_INCREF(entry);n      PyList_SetItem(retval, i, entry);n    }n    for (i=n/2; i&lt;n; i++) {n      // Py_BuildValue returns an &quot;owned reference&quot;n      // =&gt; no Py_INCREF necessaryn      entry = Py_BuildValue(&quot;i&quot;, 0);n      PyList_SetItem(retval, i, entry);n    }n    return retval;n  }nnIt is important to note that, unlike ``PyList_SetItem``, ``PyList_Append``nadds a reference to the added item, so that ``Py_INCREF`` must not bencalled in this case. In contrast, when you add an already owned referencento a list with ``PyList_Append``, you must instead decrease its referencencount with ``Py_DECREF``:nn.. code:: CPPnn  PyObject</em> myplugin(PyObject* list) {n    size_t n,i;n    PyObject <em>retval, *entry;n    n = PyList_Size(list);n    retval = PyList_New(0);n    for (i=0; i&lt;n/2; i++) {n      // PyList_Append already adds a reference to the added itemn      PyList_Append(retval, PyList_GetItem(list, i));n    }n    for (i=n/2; i&lt;n; i++) {n      // Py_BuildValue returns an &quot;owned reference&quot; whose reference countn      // is again increased by PyList_Append =&gt; Py_DECREF necessaryn      entry = Py_BuildValue(&quot;i&quot;, 0);n      PyList_Append(retval, entry);n      Py_DECREF(entry);n    }n    return retval;n  }nnnnImplementing a Python class in C++n==================================nnOccasionally it can become necessary to write some methods of a customnPython class in C++. Let us assume, you want to implement the constructornof a custom class *MyClass</em> in C++.nnThe basic idea is to write a plugin function <em>create_myclass</em> that returnsnan object of type <em>MyClass</em> and to call this function in the Pythonnconstructor, i.e. in the <tt class="docutils literal">__init__</tt> method. This requires a Pythonnwrapper of the form:nn.. code:: Pythonnn  # the class definitionn  class MyClass:n    def __init__(self, arg1, arg2):n      mc = _myplugins.create_myclass(arg1, arg2)n      # copy over properties from mc to selfn      self.property1 = mc.property1n      self.property2 = mc.property2n      # ...nn  # the plugin implementing the actual constructor of MyClassn  class create_myclass(PluginFunction):n    self_type = Nonen    args = Args([Int(&quot;arg1&quot;), Real(&quot;arg2&quot;)])n    return_type = Class('myclass', MyClass)nnThe C++ side of the <em>create_myclass</em> plugin will then be of the form (thisnprimitive example simply passes the input arguments unaltered to thennew class as properties, so it is not very useful, but nevertheless a nicendemonstration of the main ideas):nn.. code:: CPPnn  PyObject* create_myclass(int arg1, double arg2) {n    // helper variable for temporary property storagen    PyObject* prop;n    // helper object for creating class instances (see below)n    // declared static so this is initialized only oncen    static PyObject* my_class = NULL;nn    // create a dictionary and store the properties thereinn    // Note that PyDict_SetItemString (unlike PyList_SetItem) INCREFs the passed objectn    // =&gt; the no longer needed reference returned by Py_BuildValue must be DECREFedn    PyObject* class_dict = PyDict_New();n    prop = Py_BuildValue(&quot;i&quot;, arg1);n    PyDict_SetItemString(class_dict, &quot;property1&quot;, prop);n    Py_DECREF(prop);n    prop = Py_BuildValue(&quot;f&quot;, arg2);n    PyDict_SetItemString(class_dict, &quot;property2&quot;, prop);n    Py_DECREF(prop);nn    // create an instance of MyClass from the dictionaryn    if (my_class == NULL) {n      my_class = PyClass_New(NULL, PyDict_New(), PyString_FromString(&quot;MyClass&quot;));n    }n    PyObject* ret = PyInstance_NewRaw(my_class, class_dict);n    Py_DECREF(class_dict);n    return ret;n  }nn'</p>
<div class="system-message" id="id1">
<p class="system-message-title">System Message: ERROR/3 (<tt class="docutils">./src/plugins_custom_types.txt</tt>, line 1); <em><a href="#id2">backlink</a></em></p>
Unknown interpreted text role &quot;raw-html&quot;.</div>
<div class="system-messages section">
<h1>Docutils System Messages</h1>
<div class="system-message" id="id3">
<p class="system-message-title">System Message: ERROR/3 (<tt class="docutils">./src/plugins_custom_types.txt</tt>, line 2); <em>backlinks: <a href="#id4">1</a>, <a href="#id5">2</a>, <a href="#id6">3</a>, <a href="#id7">4</a></em></p>
Anonymous hyperlink mismatch: 4 references but 0 targets.
See &quot;backrefs&quot; attribute for IDs.</div>
</div>
</div>
</body>
</html>
