<?xml version="1.0" encoding="utf-8" ?>
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml" xml:lang="en" lang="en">
<head>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
<meta name="generator" content="Docutils 0.15.2: http://docutils.sourceforge.net/" />
<title>image_api.txt</title>
<link rel="stylesheet" href="default.css" type="text/css" />
</head>
<body>
<div class="document">


<p>b'========================nThe Gamera C++ Image APIn========================nn**Last modified**: June 03, 2019nn.. contents::nn.. role:: raw-html(raw)n   :format: htmln.. footer:: <a href="#id1"><span class="problematic" id="id2">:raw-html:`&lt;div style=&quot;text-align:right;&quot;&gt;For contact information, see &lt;a href=&quot;http://gamera.informatik.hsnr.de/contact.html&quot;&gt;http://gamera.informatik.hsnr.de/contact.html&lt;/a&gt;&lt;/div&gt;`</span></a>nnnIntroductionn============nnThis document describes how to manipulate Gamera images from C++.nThis deals primarily with low-level (pixel-level) operations.nnData modeln==========nnGamera uses a &quot;shared&quot; data model.  This means thatndifferent &quot;views&quot; are applied to the same &quot;data.&quot;  Views may only looknat a subset of the data, or they may change how the data is presentednto the programmer. The goal of decoupling the &quot;view&quot; from the &quot;data&quot; isnto allow a &quot;view&quot; on the data to be a very lightweight object. Thisnallows it to be passed by value with little worry about performance. Thisnalso allows the processing of a portion of an image as if it were an entirenimage.nnFor example, to create a new image, the programmer must first createnthe <a class="reference external" href="data:nn">data:nn</a>.. code:: CPPnn   OneBitImageData image_data(Dim(50, 50));nnThis creates data that is 50 pixels width and 50 pixels high, and hasna logical origin of (0, 0).nnThen you can create a view on all of the <a class="reference external" href="data:nn">data:nn</a>.. code:: CPPnn   OneBitImageView image_view(image_data);nnLater, if you want to view only a subset of the data, you can use andifferent overloaded version of the view constructor:nn.. code:: CPPnn   OneBitImageView subimage_view(image_data, Point(25, 25), Dim(10, 10));nnThis will create a view on the image from (25, 25) that is 10 pixelsntall and wide, i.e. the lower-right corner will be at (35, 35).  Annalternate way to do this would be to specify two points:nn.. code:: CPPnn   OneBitImageView subimage_view(image_data, Point(25, 25), Point(35, 35));nnThe different constructor forms are discussed in more detail in then`ImageView&lt;T&gt; objects`_ section.nnnMemory management issuesn------------------------nnSince multiple &quot;views&quot; can use the same &quot;data,&quot; one must be carefulnabout prematurely deallocating data objects, or there may be views leftnaround that &quot;point&quot; to deallocated data.  Accessing the data throughnthe view is unchecked and could result in a segmentation fault.nnAnother common mistake is to deallocate all views on a given datanobject, forgetting to deallocate the data itself, resulting in anmemory leak.  Since there is no reference counting on the C++ side,ndeallocation of all views does not automatically trigger deallocationnof the underlying data.  For example:nn.. code:: CPPnn   OneBitImageData image_data = new OneBitImageData(Dim(50, 50), Point(0, 0));n   OneBitImageView image_view = new OneBitImageView(<em>image_data);n   n   ...nn   delete image_view-&gt;data(); // Don't forget to delete the datan   delete image_view;nnOf course, if the new image data is the result of a plugin function,nit will be returned to the caller.  When a pointer to an imagenview (``ImageView*`` or one of its subclasses) is returned to Python, it willnparticipate in Python memory management, and both the view and datanwill eventually be deallocated automatically.  When an ``ImageView*``nis returned to another C++ function, that function isnresponsible for deallocating the view and data, unless it in turn is passingnit back to Python.nnFortunately, things are much easier on the Python side, since thennumber of views that point to a data object are reference counted, sonthe data object is kept around only as long as there is at least onenview looking at it.nnTake for example the following interactive Python session:nn.. code:: Pythonnn  Python 2.3.4 (#1, Oct 26 2004, 16:42:40)n  [GCC 3.4.2 20041017 (Red Hat 3.4.2-6.fc3)] on linux2n  Type &quot;help&quot;, &quot;copyright&quot;, &quot;credits&quot; or &quot;license&quot; for more information.n  &gt;&gt;&gt; from gamera.core import *n  &gt;&gt;&gt; init_gamera()n  Loading plugins: ----------------------------------------n  arithmetic, color, convolution, corelation, deformation, draw,n  edgedetect, features, gui_support, id_name_matching,n  image_conversion, image_utilities, listutilities, logical,n  misc_filters, morphology, png_support, projections, runlength,n  segmentation, structural, thinning, threshold, tiff_support, contourn  &gt;&gt;&gt; orig = load_image(&quot;test.tiff&quot;)n  &gt;&gt;&gt; del orign  # ImageData dealloc, because the only view pointing to it (orig) has been deleted.n  &gt;&gt;&gt; orig = load_image(&quot;test.tiff&quot;)n  &gt;&gt;&gt; orig = orig.otsu_threshold()n  # ImageData dealloc, because the pointer stored in orig has been replacedn  # with a new onebit image.  This effect is fairly subtle.n  &gt;&gt;&gt; ccs = orig.cc_analysis()n  &gt;&gt;&gt; del orign  # No ImageData dealloc, since the ccs list contains views on the data.n  &gt;&gt;&gt; del ccsn  # ImageData dealloc, because the remaining views on the data have been destroyed.n  &gt;&gt;&gt;nnImage typesn-----------nnYou should probably familiarize yourself with different Gamera `imagentypes`__ before reading further.nn.. __: image_types.htmlnn``ImageData&lt;T&gt;`` objectsn````````````````````````nnData objects are instances of the ``ImageData&lt;T&gt;`` class (inn``include/image_data.hpp``) where ``T`` is the pixel type.nIf you wish to use run-length encoding to store the data, you can usenthe ``RleImageData&lt;T&gt;`` class.  These classes both have the sameninterface and are completely interchangeable, but will exhibitndifferent algorithmic complexities.nnThere are some typedefs in ``image_types.hpp`` to make creatingndifferent kinds of image data objects more convenient:nn.. code:: CPPnn  /</em>n    Image Datan   <em>/n  typedef ImageData&lt;GreyScalePixel&gt; GreyScaleImageData;n  typedef ImageData&lt;Grey16Pixel&gt; Grey16ImageData;n  typedef ImageData&lt;FloatPixel&gt; FloatImageData;n  typedef ImageData&lt;RGBPixel&gt; RGBImageData;n  typedef ImageData&lt;OneBitPixel&gt; OneBitImageData;n  typedef RleImageData&lt;OneBitPixel&gt; OneBitRleImageData;nnThere are a few different constructors available for data objects:nn.. code:: CPPnn    ImageData(const Dim&amp; dim, const Point&amp; offset);n    ImageData(const Dim&amp; dim); // offset == (0, 0)n    ImageData(const Size&amp; size, const Point&amp; offset);n    ImageData(const Size&amp; size); // offset == (0, 0)n    ImageData(const Rect&amp; rect);nnThere are also some deprecated forms that you may see in legacy code,nbut which are no longer supported since they are not consistent aboutnspecifying *x</em> before <em>y</em>:nn.. code:: CPPnn    ImageData(size_t nrows = 1, size_t ncols = 1, size_t page_offset_y = 0,nt      size_t page_offset_x = 0);n    ImageData(const Size&amp; size, size_t page_offset_y = 0,nt      size_t page_offset_x = 0);n    ImageData(const Dimensions&amp; dim, size_t page_offset_y = 0,nt      size_t page_offset_x = 0);nnThe <em>offset</em> arguments are used to specify a logical offset of thendata.  For instance, if the image data is from part of the page, thenupper left corner may not be logically (0, 0).  This is purely fornlogical purposes when your system needs to know the relative positionsnof image bounding boxes, and does not affect the size of the imagendata created in any way.nnThe <tt class="docutils literal">Size</tt> and <tt class="docutils literal">Dim</tt> classes are simple ways of storingnsizes and dimensions defined in <tt class="docutils literal">gamera/dimensions.hpp</tt>.  (See then`Dimension types`__ chapter for more information). <tt class="docutils literal"><span class="pre">Size(w,\nh)</span></tt> is always equal to <tt class="docutils literal">Dim(w + 1, h + 1)</tt>.  Both forms arensupported to make it easier to adapt existing algorithms that use onenor the other standard.nn.. __: dimension_types.htmlnnWhile there are other public members and methods to the <tt class="docutils literal">ImageData</tt>nclass, we do not recommend using any of them unless you really knownwhat you're doing.  All of the image data can be accessed much morenflexibly and conveniently through <tt class="docutils literal">ImageView</tt> objects.nn``ImageView&lt;T&gt;`` objectsn````````````````````````nnViews objects are instances of the <tt class="docutils literal">ImageView&lt;T&gt;</tt> class (inn``include/image_view.hpp``), where <tt class="docutils literal">T</tt> is the data object type (antemplatization of <tt class="docutils literal">ImageData&lt;T&gt;</tt>).  There is also a special versionnof <tt class="docutils literal">ImageView&lt;T&gt;</tt> for connected components,n``ConnectedComponent&lt;T&gt;`` defined inn``include/connected_components.hpp``.  <a href="#id6"><span class="problematic" id="id7">`Connected components`_</span></a> arendiscussed below.nnAs with the data objects, there are some typedefs for convenience:nn.. code:: CPPnn  /<em>n    ImageViewn   */n  typedef ImageView&lt;GreyScaleImageData&gt; GreyScaleImageView;n  typedef ImageView&lt;Grey16ImageData&gt; Grey16ImageView;n  typedef ImageView&lt;FloatImageData&gt; FloatImageView;n  typedef ImageView&lt;RGBImageData&gt; RGBImageView;n  typedef ImageView&lt;OneBitImageData&gt; OneBitImageView;n  typedef ImageView&lt;OneBitRleImageData&gt; OneBitRleImageView;nn  /</em>n    Connected-componentsn   <em>/n  typedef ConnectedComponent&lt;OneBitImageData&gt; Cc;n  typedef ConnectedComponent&lt;OneBitRleImageData&gt; RleCc;nnThere are a number of different ways to construct image views:nn.. code:: CPPnn  // Creates a view covering all of the datan  ImageView(T&amp; image_data);nn  ImageView(T&amp; image_data, const Rect&amp; rect, n            bool do_range_check = true);n  ImageView(T&amp; image_data, const Point&amp; upper_left,nt    const Point&amp; lower_right, bool do_range_check = true)n  ImageView(T&amp; image_data, const Point&amp; upper_left,nt    const Size&amp; size, bool do_range_check = true)n  ImageView(T&amp; image_data, const Point&amp; upper_left,nt    const Dim&amp; dim, bool do_range_check = true)n  nThere are also some deprecated forms that you may see in legacy code,nbut which are no longer supported since they are not consistent aboutnspecifying *x</em> before <em>y</em>:nn.. code:: CPPnn  // Creates a view with a specified bounding boxn  ImageView(T&amp; image_data, size_t offset_y,nt    size_t offset_x, size_t nrows, size_t ncols,nt    bool do_range_check = true);n  ImageView(T&amp; image_data, const Point&amp; upper_left,nt    const Dimensions&amp; dim, bool do_range_check = true)nnThe <tt class="docutils literal">Size</tt>, <tt class="docutils literal">Point</tt> and <tt class="docutils literal">Dim</tt> classes are simple ways of storingnsizes and dimensions defined in <tt class="docutils literal">gamera/dimensions.hpp</tt>.  (See then`Dimension types`__ chapter for more information).nn.. __: dimension_types.htmlnnCoordinates for any given bounding boxes are relative to the offset ofnthe underlying data.  Therefore:nn.. code:: CPPnn   // Create data with a size of (64, 64) and an offset of (32, 32);n   OneBitImageData image_data(Size(64, 64), Point(32, 32));n   // This is a view over all of the datan   OneBitImageView image_view(image_data, Point(32, 32), Size(64, 64));n   // This raises an exception, since it's out of range for the datan   OneBitImageView image_view(image_data, Point(0, 0), Size(64, 64));nnYou can get the type of the pixels referenced by an <tt class="docutils literal">ImageView</tt>nusing the expression <tt class="docutils literal">typename <span class="pre">T::value_type</span></tt>.nnImage factoriesn---------------nnThere are other convenience classes for creating image types.nnTypeIdImageFactoryn``````````````````nn``TypeIdImageFactory`` is useful if you want to create an image of anspecific type based on a pair of integer constants.  For example, thenfollowing code snippit creates a DENSE or RLE image based on anninteger constant passed in as a parameter to the function.  Note thatnthe types of each of the <tt class="docutils literal">TypeIdImageFactory</tt> s are different andnnot polymorphic, so the interior function (<tt class="docutils literal">threshold_fill</tt>) must bencalled from two locations.nn.. code:: CPPnn   template&lt;class T&gt;n   Image* threshold(const T &amp;m, int threshold, int storage_format) {n     if (storage_format == DENSE) {n       typedef TypeIdImageFactory&lt;ONEBIT, DENSE&gt; fact_type;n       typename fact_type::image_type* view = fact_type::create(m.origin(), m.dim());n       threshold_fill(m, <em>view, threshold);n       return view;n     } else {n       typedef TypeIdImageFactory&lt;ONEBIT, RLE&gt; fact_type;n       typename fact_type::image_type</em> view = fact_type::create(m.origin(), m.dim());n       threshold_fill(m, <em>view, threshold);n       return view;n     }n   }nnImageFactoryn````````````nnIt is a common use case to create a result image whose type is relatednto the type of an input image.  In many cases, one could just use thensame type as the result type.  However, if a ``Cc`` image type isnpassed into a function, you would most likely want to return a regularn``OneBit`` image as a result.  ``ImageFactory`` is designed to getnaround this problem.  It will create an appropriate result type fromna given input type.  For example, see the following code snippet:nn.. code:: CPPnn   template&lt;class T&gt;n   Image</em> abutaleb_threshold(const T &amp;m, int storage_format) {n     typedef typename ImageFactory&lt;T&gt;::view_type view_type;n     view_type* average = mean(m);n   ...nnAccessing pixelsn================nnOne of the goals of the Gamera framework is to make it easy tonincorporate code from other image processing frameworks as painlesslynas possible.  Therefore, there are a number of interfaces that can benused to access and process the underlying pixel data of an image.nn.. note:: Whenever accessing individual pixels, the <tt class="docutils literal">row</tt> and <tt class="docutils literal">col</tt>n   given are relative to the offsets of the view or then   underlying data.  In other words <tt class="docutils literal">.get(0,0)</tt> will always returnn   the pixel in the upper-left hand corner of the view.  This makes itn   easier for algorithms that work on the pixels of a view to ignoren   the complexity of the &quot;shared&quot; data model.nnDifferent interfacesn--------------------nnThe different interfaces for accessing pixels are discussed below:nn``get`` and <tt class="docutils literal">set</tt> methodsn```````````````````````````nnThis is perhaps the most straightforward way to access the pixels ofnan image.  There are two public methods of <tt class="docutils literal">ImageView</tt>:nn   - value_type <strong>get</strong> (const Point&amp; <em>point</em>)nn   - void <strong>set</strong> (const Point&amp; <em>point</em>, value_type <em>value</em>)nnThere are also deprecated forms that you may see in legacy code:nn   - value_type <strong>get</strong> (size_t <em>row</em>, size_t <em>col</em>)nn   - void <strong>set</strong> (size_t <em>row</em>, size_t <em>col</em>, value_type <em>value</em>)nn**get** returns the value of the pixel at the given row and column. n**set** changes the pixel at the given row and column to the givennvalue.nnAn example using <tt class="docutils literal">get</tt> / <tt class="docutils literal">set</tt> over an entire image:nn.. code:: CPPnn  template&lt;class T&gt;n  typename ImageFactory&lt;T&gt;::view_type* test_get_set(const T&amp; image) {n    typedef typename ImageFactory&lt;T&gt;::data_type data_type;n    typedef typename ImageFactory&lt;T&gt;::view_type view_type;n    data_type* new_data = new data_type(image);n    view_type* new_view = new view_type(<em>new_data);n    n    for (size_t r = 0; r &lt; in.nrows(); ++r) {n      for (size_t c = 0; c &lt; in.ncols(); ++c) {ntnew_view.set(Point(c, r), image.get(Point(c, r)) / 2);n      }n    }nn    return new_view;n  }nnnC-style 2-dimensional arrayn```````````````````````````nnAn alternative is to use the notation of C-style 2-dimensionalnarrays:nn.. code:: CPPnn   value = image[row][col];n   image[row][col] = value;nnThis interface is provided as a convenience to support the large bodynof legacy code written in this style.  Note that ``[row][col]`` is thenreverse of get and set's ``Point(x, y)``.  Keep in mind, it is not reallyna 2-dimensional array underneath -- this view is &quot;faked.&quot;nnAn example using the C-style 2-dimensional array interface:nn.. code:: CPPnn  template&lt;class T&gt;n  typename ImageFactory&lt;T&gt;::view_type</em> test_c_2d(const T&amp; image) {n    typedef typename ImageFactory&lt;T&gt;::data_type data_type;n    typedef typename ImageFactory&lt;T&gt;::view_type view_type;n    data_type* new_data = new data_type(image);n    view_type* new_view = new view_type(<em>new_data);n    n    for (size_t r = 0; r &lt; image.nrows(); ++r) {n      for (size_t c = 0; c &lt; image.ncols(); ++c) {nt(*new_view)[r][c] = image[r][c] / 2;n      }n    }nn    return new_view;n  }nnIteratorsn`````````nnIterators provide a lot of readability and convenience advantages overnthe other approaches.nnGamera has three kinds of iterators:nn1. Vector iterator: a one-dimensional iterator that iterates from then   upper left hand corner, left-to-right, top-to-bottom.n2. Row/column iterators: Iterates along either rows or columns.  Incrementing the iteratorn   moves one row down or one column to the right.  Calling ``begin()`` on a ``row_iterator``,n   returns a ``col_iterator`` and vice versa.n3. Two-dimensional iterators: Provide free movement of the iterator inn   any direction.nnThe first two kinds of iterators follow the conventions of the C++ STLnenough that they can be used with STL algorithms.  All iterators arenavailable in ``const`` and non-``const`` versions.  ``const``niterators cannot change the underlying data.  If you have an imagenpassed into your function as a ``const ImageView&lt;T&gt; &amp;``, you will notnbe able to change the pixels in the image, and thus will only be ablento get ``const`` iterators from it.nnNote that you can call ``row( )`` or ``col( )`` on anyniterator to obtain the current row and column position of the iterator.nnAll Gamera iterators can get/set their values in two ways, both ofnwhich boiling down to exactly the same machine code, and thereforenhaving the same efficiency:nn1. The standard &quot;C pointer-like&quot; way:nn.. code:: CPPnn   // i is any iterator typen   value = *i;n   *i = value;nn2. Using ``get`` and ``set`` methods:n   n.. code:: CPPnn   // i is any iterator typen   value = i.get();n   i.set(value);nnVector iteratorn'''''''''''''''nnVector iterators (``ImageView&lt;T&gt;::vec_iterator``) can be convenient when the operation works one pixelnat a time and does not need to be aware of any spatial relationships.nnAn example using ``vec_iterators``:nn.. code:: CPPnn  template&lt;class T&gt;n  typename ImageFactory&lt;T&gt;::view_type</em> test_vec_iterator(const T&amp; image) {n    typedef typename ImageFactory&lt;T&gt;::data_type data_type;n    typedef typename ImageFactory&lt;T&gt;::view_type view_type;n    data_type* new_data = new data_type(image);n    view_type* new_view = new view_type(<em>new_data);nn    typename T::const_vec_iterator i = image.vec_begin();n    typename view_type::vec_iterator j = new_view-&gt;vec_begin();nn    for ( ; i != image.vec_end(); ++i, ++j) {n      *j = *i / 2;  // or  j.set(i.get() / 2);n    }nn    return new_view;n  }nnSince the Gamera image iterators follow the STL iterator interface,nthey can be used with builtin STL algorithms.  For instance, to fillnan entire image with white using the STL ``std::fill`` algorithm:nn.. code:: CPPnn  #include &lt;algorithm&gt; nn  template&lt;class T&gt;n  void fill_white(T&amp; image) {n    std::fill(image.vec_begin(), image.vec_end(), white(image));n  }nnRow/column iteratorsn''''''''''''''''''''nnSometimes it is necessary to have nested loops, one for rows and onenfor columns.nnThe following is an example using row iterators (``ImageView&lt;T&gt;::row_iterators``) andncolumn iterators (``ImageView&lt;T&gt;::col_iterators``):nn.. code:: CPPnn  template&lt;class T&gt;n  typename ImageFactory&lt;T&gt;::view_type</em> test_row_col_iterator(const T&amp; image) {n    typedef typename ImageFactory&lt;T&gt;::data_type data_type;n    typedef typename ImageFactory&lt;T&gt;::view_type view_type;n    data_type* new_data = new data_type(image);n    view_type* new_view = new view_type(<em>new_data);nn    typedef typename T::const_row_iterator IteratorI;n    IteratorI ir = image.row_begin();n    typedef typename view_type::row_iterator IteratorJ;n    IteratorJ jr = new_view-&gt;row_begin();n    for ( ; ir != image.row_end(); ++ir, ++jr) {n      typename IteratorI::iterator ic = ir.begin();n      typename IteratorJ::iterator jc = jr.begin();n      for ( ; ic != ir.end(); ++ic, ++jc)nt*jc = *ic / 2;n    }nn    return new_view;n  }nnThe fun thing about row and column iterators is that they areninterchangeable.  If you wish to iterate through the image in columnnmajor order instead, you could write:nn.. code:: CPPnn  template&lt;class T&gt;n  typename ImageFactory&lt;T&gt;::view_type</em> test_col_row_iterator(const T&amp; image) {n    typedef typename ImageFactory&lt;T&gt;::data_type data_type;n    typedef typename ImageFactory&lt;T&gt;::view_type view_type;n    data_type* new_data = new data_type(image);n    view_type* new_view = new view_type(<em>new_data);nn    typedef typename T::const_col_iterator IteratorI;n    IteratorI ir = image.col_begin();n    typedef typename view_type::col_iterator IteratorJ;n    IteratorJ jr = new_view-&gt;col_begin();n    for ( ; ir != image.col_end(); ++ir, ++jr) {n      typename IteratorI::iterator ic = ir.begin();n      typename IteratorJ::iterator jc = jr.begin();n      for ( ; ic != ir.end(); ++ic, ++jc)nt*jc = *ic / 2;n    }nn    return new_view;n  }nnOf course, that really should be templatized on the iterator type.nFor an example of this, see ``include/plugins/projections.hpp``.nnRow and column iterators also have methods that return the current rownand column (relative to the underlying data).  ``i.row()`` returns thencurrent row and ``i.col()`` returns the current column.nnTwo-dimensional iteratorsn'''''''''''''''''''''''''nnUnlike the other kinds of iterators, two-dimensional iterators are anlong way from C++ STL convention.  The idea of these iterators wasnborrowed from the VIGRA_ library.  More documentation is availablenthere, but I've provided a short summary below.nn.. _VIGRA: http://kogs-www.informatik.uni-hamburg.de/~koethe/vigra/nnYou can obtain a two-dimensional iterator from an image using ofnthe following methods:nn.. code:: CPPnn    Iterator upperLeft();n    Iterator lowerRight();nnOnce you have a two-dimensional iterator, you can move it using thenfollowing:nn.. code:: CPPnn   typename T::Iterator i;n   n   ++i.x; // move rightn   --i.x; // move leftn   ++i.y; // move downn   --i.y; // move upnnYou can see that this gives more freedom and expressivity than thenother iterators.nnWhen you assign one two-dimensional iterator to another, it is copied,nso there are no persistent connections between them.nn.. code:: CPPn   n   typename T::Iterator center, below;n   n   ...nn   below = center;n   ++below.y;t// 'below' points to the pixel below 'center'n   ++center.x;  // 'center' moved.  'below' did not.nnYou can also perform arithmetic on these iterators on the fly:nn.. code:: CPPnn   typename T::Iterator center, below;n   n   ...nn   below = center.y + 1; // 'center' is not movednnIf you need to move in two dimensions at once, you can either add or subtractna ``Diff2D`` object from the iterator, or use the ``operator()``nmethod.nn.. code:: CPPnn   typename T::Iterator i, relative;n   n   ...nn   relative = i + Diff2D(1, 1)   // down and to the rightn   relative = i[Diff2D(1, 1)]    // equivalent to aboven   relative = i + Diff2D(-1, -1) // up and to the leftnn   relative = i - Diff2D(1, 1)   // up and to the leftn   relative = i - Diff2D(-1, -1) // down and to the rightnn   relative = i(1, 1)            // down and to the rightn   relative = i(-1, -1)t         // up and to the leftnnFor an example of how two-dimensional iterators can be used in a morenreal-world situation, see the ``cc_analysis`` method inn``include/plugins/segmentation.py``.nnSpeed testsn```````````nnThe different interfaces are provided primarily to support differentnprogramming styles.  However, they do not run at the same speed.nnThe following graph shows the relative speeds of different pixelnaccess methods (using the examples above).  These results are largelynprocessor and architecture dependent, so take them with a truckload ofnsalt.nn.. image:: images/pixel_access_runtimes.pngnnThe performance of the 1-dimensional iterator is perhaps surprising,nsince it appears to be the simplest code.  In fact, however,n``vec_iterators`` must support the image view model, and therefore donbasic &quot;range checking&quot; upon each increment.  This introduces somenoverhead.nn.. _VIGRA: http://kogs-www.informatik.uni-hamburg.de/~koethe/vigra/nnThe row/column iterators in row major order (rows in the outer loop) isnthe clear winner.  Since the underlying data is stored row major order,naccessing it in column major order is a major performance hit, in partndue to the extra pointer arithmetic and in part due to worse cache performance.nn.. note:: Any performance improvement should be justified only byn   profiling on real-world datannMaking generic programming workn===============================nnEverything discussed so far has been completely polymorphic: these techniquesnshould work identically on all types of images.  However, where thenimages vary is in the pixel types themselves.  Careful programmingncan keep your algorithms generic across all pixel types, but whennthat is no longer possible, it is also possible to specializen(i.e. write a special version of an algorithm for a particular pixelntype.)nnFirst, let's cover some more details of the various pixel typesnavailable in Gamera.  They are all defined in ``include/pixel.hpp``.nn``RGB``ntRGB pixels are represented by instances of the ``Rgb`` class.ntBy default, each plane is represented by an 8-bit ``unsigned char``ntThe individual RGB planes can be get/set using the ``red``,nt``green`` and ``blue`` functions.  The values follow thentstandard hardware conventions: larger values are higherntintensity.n        There are also many utility methodsntfor converting the RGB pixel into other kinds ofntvalues.  See ``include/pixel.hpp`` for more information.nt``Rgb`` instances are small enough (3 bytes) that you can safely passntthem by value without performance concerns.nn``GREYSCALE``ntGreyScale pixels are 8-bit ``unsigned char`` values in the range 0nt- 255.  These alsontfollow the hardware convention that larger values are higherntintensity (white).nn``FLOAT``ntFloat pixels are 32-bit floating-point ``float`` values.  Theyntfollows the hardware convention that larger values are higherntintensity (white).  Unlike the integral pixel types, there isntno set range for the values (they can even be negative).  Forntthis reason, the Gamera display will always find the lowestntand highest values and then normalize the display to match thentdynamic range of the display hardware.  Floating point imagesntare most useful to represent non-image data, such as thentresults of the convolution of two images.nn``ONEBIT``ntOneBit pixels are 16-bit ``unsigned char`` values.  Perhapsntconfusingly, a value of 0 is white (which is usuallynt``background`` in most document images) and *all other values</em>ntare black.  The extra bits of range are used when a connectedntcomponent analysis is performed.  Each connected component inntan image is assigned a <tt class="docutils literal">label</tt> value, and its pixels arentlabeled using the value.  Since the directionality of OneBitntpixels is different from all other pixel types, care must benttaken when writing algorithms that accept OneBit images andntother images.nnBlack and whiten---------------nnConvenience functions are provided to get and test values for whitenand black pixels that work on all pixel types.nn.. code:: CPPnn  T pixel_traits&lt;T&gt;::white();n  T pixel_traits&lt;T&gt;::black();nnReturn the values for white and black, respectively, for the givennpixel type <tt class="docutils literal">T</tt>.  Often, it is more convenient to get the pixel valuenfrom the <tt class="docutils literal">ImageView</tt> type, and not the pixel type.  Therefore, thenfunctionsnn.. code:: CPPnn  T::value_type white(T&amp; image_type);n  T::value_type black(T&amp; image_type);nnare also provided.nnYou can also test whether a pixel is white or black using:nn.. code:: CPPnn  bool is_white(T pixel_value);n  bool is_black(T pixel_value);nnWriting a specialized functionn------------------------------nnAs specified in <a href="#id3"><span class="problematic" id="id4">`Writing Gamera Plugins`__</span></a>, each plugin functionnshould be templatized to accept multiple image types.  Sometimes,nthough, a single code base will not work for all images types, ornthere are performance gains to be had by writing for a particularnimage type.nn.. __: writing_plugins.htmlnnThe wrinkle that makes this less than straightforward is that younoften want to specialize on the <strong>pixel type</strong>, not the <strong>imagentype</strong>.  For instance, there are multiple <strong>image types</strong> where then**pixel type** is <tt class="docutils literal">ONEBIT</tt> (OneBitImageView, Cc, OneBitRleImageViewnetc.).  Therefore, you will normally want to have a helper functionnwhich is templatized on the pixel type, which is called from the mainnfunction.  See for example, the <tt class="docutils literal">invert</tt> plugin method, which needsnto do something different for FLOAT images (since the range of FLOATnpixels is not fixed.):nn.. code:: CPPnn  /* Invert an image <em>/nn  // This is the generic versionn  template&lt;class Pixel&gt;n  struct invert_specialized {n    template&lt;class T&gt;n    void operator()(T&amp; image) {n      ImageAccessor&lt;typename T::value_type&gt; acc;n      typename T::vec_iterator in = image.vec_begin();n      for (; in != image.vec_end(); ++in)ntacc.set(invert(acc(in)), in);n    }n  };nn  // This is specialized for FLOAT pixelsn  template&lt;&gt;n  struct invert_specialized&lt;FloatPixel&gt; {n    template&lt;class T&gt;n    void operator()(T&amp; image) {n      FloatPixel max = 0;n      max = find_max(image.parent());n      ImageAccessor&lt;FloatPixel&gt; acc;n      typename T::vec_iterator in = image.vec_begin();n      for (; in != image.vec_end(); ++in)ntacc.set(max - acc(in), in);n    }n  };nn  // This is the top level function that calls the correctn  // specializationn  template&lt;class T&gt;n  void invert(T&amp; image) {n    invert_specialized&lt;typename T::value_type&gt; invert_special;n    invert_special(image);n  }nnnConnected componentsn====================nnOn the C++ side, the Python image type ``Cc`` corresponds to thenimage type ``ConnectedComponent``. You can us it just like in Python:nn.. code:: CPPnn  ImageList</em> ccs = cc_analysis(image);n  ImageList::iterator ccs_it;n  size_t x,y;nn  // loop over all ccsn  for (ccs_it = ccs-&gt;begin(); ccs_it != ccs-&gt;end(); ++ccs_it) {nn    Cc* cc = static_cast&lt;Cc*&gt;(<em>ccs_it);nn    // query cc labeln    int label = cc-&gt;label();nn    // Loop over individual pixelsn    for (y=0; y &lt; cc-&gt;nrows(); y++)n      for (x=0; x &lt; cc-&gt;ncols(); x++)n        if is_black(cc-&gt;get(Point(x,y))) { // .... }n  }nnFor creating a list of CCs from C++, two steps are necessary:nn 1) Setting all pixels in the image to its label valuenn 2) Call the constructor for each ConnectedComponent:nn    .. code:: CPPnn      // Assumptions:n      //   the CC labels have been stored in the vector &quot;labelvec&quot;n      //   the CC dimensions have been stored in the vector &quot;rectvec&quot;n      ccs = new ImageList();n      for (size_t i = 0; i &lt; labelvec.size(); ++i) {n        ccs-&gt;push_back(new ConnectedComponent&lt;typename T::data_type&gt;(n                         *((typename T::data_type</em>)image.data()),n                         labelvec[i],n                         Point(rectvec[i]-&gt;offset_x() + image.offset_x(),n                               rectvec[i]-&gt;offset_y() + image.offset_y()),n                         rectvec[i]-&gt;dim()n                        ));n      }nnnMulti-label connected componentsn================================nnOn the C++ side, the Python image type <tt class="docutils literal">MlCc</tt> corresponds to thenimage type <tt class="docutils literal">MultiLabelCC</tt> (two upper case C's at the end). Itsnmethods are the <a href="#id3"><span class="problematic" id="id5">`same as on the Python side`__</span></a>; for details aboutnits C++ constructors and properties (<tt class="docutils literal">m_labels</tt> etc.) see thensource file <em>include/connected_component.hpp</em> of the Gamera sourcencode.nn.. __: image_types.html#multi-label-connected-componentsnn'</p>
<div class="system-message" id="id1">
<p class="system-message-title">System Message: ERROR/3 (<tt class="docutils">./src/image_api.txt</tt>, line 1); <em><a href="#id2">backlink</a></em></p>
Unknown interpreted text role &quot;raw-html&quot;.</div>
<div class="system-messages section">
<h1>Docutils System Messages</h1>
<div class="system-message" id="id3">
<p class="system-message-title">System Message: ERROR/3 (<tt class="docutils">./src/image_api.txt</tt>, line 2); <em>backlinks: <a href="#id4">1</a>, <a href="#id5">2</a></em></p>
Anonymous hyperlink mismatch: 2 references but 0 targets.
See &quot;backrefs&quot; attribute for IDs.</div>
<div class="system-message" id="id6">
<p class="system-message-title">System Message: ERROR/3 (<tt class="docutils">./src/image_api.txt</tt>, line 1); <em><a href="#id7">backlink</a></em></p>
Unknown target name: &quot;connected components&quot;.</div>
</div>
</div>
</body>
</html>
